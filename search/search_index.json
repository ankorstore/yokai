{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Yokai","text":"<p>A <code>simple</code>, <code>modular</code> and <code>observable</code> Go framework for <code>backend applications</code>.</p> <p></p>"},{"location":"#goals","title":"Goals","text":"<p>Building backend applications with Go is amazing.</p> <p>But to build <code>production-grade</code> applications, you need to put in place a bunch of efforts and boilerplate code, introducing complexity not even related to the logic of your application (like dependencies wiring, configuration management, observability instrumentation, etc.).</p> <p>To solve this, Yokai was created with the following goals in mind:</p> <ul> <li><code>Simple</code>: it is easy to use, configure and test, enabling you to iterate fast and deliver quickly maintainable applications.</li> <li><code>Modular</code>: it can be extended with the available Yokai modules, or with your own, to build evolvable applications.</li> <li><code>Observable</code>: it comes with built-in logging, tracing and metrics instrumentation, to build reliable applications.</li> </ul> <p>In other words, Yokai lets you focus on your application logic, while taking care of the rest.</p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#architecture","title":"Architecture","text":"<ul> <li>Yokai <code>core modules</code> preloads logging, tracing, metrics and health check instrumentation, and expose a private HTTP server for infrastructure and debugging needs.</li> <li>Yokai <code>extensions modules</code> can be added to enrich your application features, like public HTTP / gRPC servers, workers, ORM, etc. You can also add the contrib modules or your own.</li> <li>Those are made available in Yokai <code>dependency injection system</code>, on which you can rely to build your application logic.</li> </ul>"},{"location":"#foundations","title":"Foundations","text":"<p>Yokai was built using <code>robust</code> and <code>well known</code> Go libraries, such as:</p> <ul> <li>Echo for HTTP servers</li> <li>gRPC-go for gRPC servers</li> <li>Viper for configuration management</li> <li>OTEL for observability instrumentation</li> <li>Fx for dependency injection system</li> <li>and more.</li> </ul>"},{"location":"#extensions","title":"Extensions","text":"<p>Yokai's <code>extension system</code> enables you to <code>enrich</code> your application features with:</p> <ul> <li>the Yokai <code>built-in</code> modules</li> <li>the Yokai contrib modules</li> <li>your own modules</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>Yokai provides ready to use <code>application templates</code> to start your projects:</p> <ul> <li>for gRPC applications</li> <li>for HTTP applications</li> <li>for MCP applications</li> <li>for worker applications</li> </ul>"},{"location":"demos/grpc-application/","title":"Demo - gRPC application","text":"<p>Yokai's showroom provides a gRPC demo application.</p>"},{"location":"demos/grpc-application/#overview","title":"Overview","text":"<p>This gRPC demo application is a simple gRPC API offering a text transformation service.</p> <p>It provides:</p> <ul> <li>a Yokai application container, with the gRPC server module to offer the gRPC API</li> <li>a Jaeger container to collect the application traces</li> </ul>"},{"location":"demos/grpc-application/#layout","title":"Layout","text":"<p>This demo application is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>api/</code>: gRPC API</li> <li><code>interceptor/</code>: gRPC interceptors</li> <li><code>service/</code>: gRPC services</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> <li><code>proto/</code>: protobuf definition and stubs</li> </ul>"},{"location":"demos/grpc-application/#makefile","title":"Makefile","text":"<p>This demo application provides a <code>Makefile</code>:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake stubs  # generate gRPC stubs with protoc (ex: make stubs from=proto/transform.proto)\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"demos/grpc-application/#usage","title":"Usage","text":""},{"location":"demos/grpc-application/#start-the-application","title":"Start the application","text":"<p>To start the application, simply run:</p> <pre><code>make fresh\n</code></pre> <p>After a short moment, the application will offer:</p> <ul> <li><code>localhost:50051</code>: application gRPC server</li> <li>http://localhost:8081: application core dashboard</li> <li>http://localhost:16686: jaeger UI</li> </ul>"},{"location":"demos/grpc-application/#available-services","title":"Available services","text":"<p>This demo application provides a TransformTextService, with the following <code>RPCs</code>:</p> RPC Type Description <code>TransformText</code> unary Transforms a given text using a given transformer <code>TransformAndSplitText</code> streaming Transforms and splits a given text using a given transformer <p>If no <code>Transformer</code> is provided, the transformation configured in <code>config.transform.default</code> will be applied.</p> <p>If you update the proto definition, you can run <code>make stubs from=proto/transform.proto</code> to regenerate the stubs.</p> <p>This demo application also provides reflection and health check  services.</p>"},{"location":"demos/grpc-application/#authentication","title":"Authentication","text":"<p>This demo application provides example authentication interceptors.</p> <p>You can enable authentication in the application configuration file with <code>config.authentication.enabled=true</code>.</p> <p>If enabled, you need to provide the secret configured in <code>config.authentication.secret</code> as context <code>authorization</code> metadata.</p>"},{"location":"demos/grpc-application/#examples","title":"Examples","text":"<p>Usage examples with gRPCurl:</p> <ul> <li>with <code>TransformTextService/TransformText</code>:</li> </ul> <pre><code>grpcurl -plaintext -d '{\"text\":\"abc\",\"transformer\":\"TRANSFORMER_UPPERCASE\"}' localhost:50051 transform.TransformTextService/TransformText\n{\n  \"text\": \"ABC\"\n}\n</code></pre> <ul> <li>with <code>TransformTextService/TransformAndSplitText</code>:</li> </ul> <pre><code>grpcurl -plaintext -d '{\"text\":\"ABC DEF\",\"transformer\":\"TRANSFORMER_LOWERCASE\"}' localhost:50051 transform.TransformTextService/TransformAndSplitText\n{\n  \"text\": \"abc\"\n}\n{\n  \"text\": \"def\"\n}\n</code></pre> <p>You can use any gRPC clients, for example Postman or Evans.</p>"},{"location":"demos/http-application/","title":"Demo - HTTP application","text":"<p>Yokai's showroom provides an HTTP demo application.</p>"},{"location":"demos/http-application/#overview","title":"Overview","text":"<p>This HTTP demo application is a simple REST API (CRUD) to manage gophers.</p> <p>It provides:</p> <ul> <li>a Yokai application container, with the HTTP server and SQL modules to offer the gophers API</li> <li>a MySQL container to store the gophers</li> <li>a Jaeger container to collect the application traces</li> </ul>"},{"location":"demos/http-application/#layout","title":"Layout","text":"<p>This demo application is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>db/</code>:<ul> <li><code>migrations/</code>: database migrations</li> <li><code>seeds/</code>: database seeds</li> </ul> </li> <li><code>internal/</code>:<ul> <li><code>api/</code>: HTTP API<ul> <li><code>handler/</code>: HTTP handlers</li> <li><code>middleware/</code>: HTTP middlewares</li> </ul> </li> <li><code>domain/</code>: domain<ul> <li><code>model.go</code>: gophers model</li> <li><code>repository.go</code>: gophers repository</li> <li><code>service.go</code>: gophers service</li> </ul> </li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> <li><code>router.go</code>: routing registration</li> </ul> </li> <li><code>templates/</code>: HTML templates</li> </ul>"},{"location":"demos/http-application/#makefile","title":"Makefile","text":"<p>This demo application provides a <code>Makefile</code>:</p> <pre><code>make up      # start the docker compose stack\nmake down    # stop the docker compose stack\nmake logs    # stream the docker compose stack logs\nmake fresh   # refresh the docker compose stack\nmake migrate # run database migrations\nmake test    # run tests\nmake lint    # run linter\n</code></pre>"},{"location":"demos/http-application/#usage","title":"Usage","text":""},{"location":"demos/http-application/#start-the-application","title":"Start the application","text":"<p>To start the application, simply run:</p> <pre><code>make fresh\n</code></pre> <p>After a short moment, the application will offer:</p> <ul> <li>http://localhost:8080: application dashboard</li> <li>http://localhost:8081: application core dashboard</li> <li>http://localhost:16686: jaeger UI</li> </ul>"},{"location":"demos/http-application/#available-endpoints","title":"Available endpoints","text":"<p>On http://localhost:8080, you can use:</p> Route Description Type <code>[GET] /</code> Dashboard template <code>[GET] /gophers</code> List all gophers REST <code>[POST] /gophers</code> Create a gopher REST <code>[GET] /gophers/:id</code> Get a gopher REST <code>[DELETE] /gophers/:id</code> Delete a gopher REST"},{"location":"demos/http-application/#authentication","title":"Authentication","text":"<p>This demo application provides an example authentication middleware.</p> <p>You can enable authentication in the application configuration file with <code>config.authentication.enabled=true</code>.</p> <p>If enabled, you need to provide the secret configured in <code>config.authentication.secret</code> as request <code>Authorization</code> header.</p>"},{"location":"demos/mcp-application/","title":"Demo - MCP application","text":"<p>Yokai's showroom provides an MCP server demo application.</p>"},{"location":"demos/mcp-application/#overview","title":"Overview","text":"<p>This MCP server demo application is a simple MCP server to manage gophers.</p> <p>It provides:</p> <ul> <li>a Yokai application container, with the MCP server and SQL modules to offer the gophers MCP server</li> <li>a MySQL container to store the gophers</li> <li>a MCP Inspector container to interact with the MCP server</li> <li>a Jaeger container to collect the application traces</li> </ul>"},{"location":"demos/mcp-application/#layout","title":"Layout","text":"<p>This demo application is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>db/</code>:<ul> <li><code>migrations/</code>: database migrations</li> <li><code>seeds/</code>: database seeds</li> </ul> </li> <li><code>internal/</code>:<ul> <li><code>domain/</code>: domain<ul> <li><code>model.go</code>: gophers model</li> <li><code>repository.go</code>: gophers repository</li> <li><code>service.go</code>: gophers service</li> </ul> </li> <li><code>mcp/</code>: MCP registrations<ul> <li><code>prompt/</code>: MCP prompts</li> <li><code>resource/</code>: MCP resources</li> <li><code>tool/</code>: MCP tools</li> </ul> </li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> </ul>"},{"location":"demos/mcp-application/#makefile","title":"Makefile","text":"<p>This demo application provides a <code>Makefile</code>:</p> <pre><code>make up      # start the docker compose stack\nmake down    # stop the docker compose stack\nmake logs    # stream the docker compose stack logs\nmake fresh   # refresh the docker compose stack\nmake migrate # run database migrations\nmake test    # run tests\nmake lint    # run linter\n</code></pre>"},{"location":"demos/mcp-application/#usage","title":"Usage","text":""},{"location":"demos/mcp-application/#start-the-application","title":"Start the application","text":"<p>To start the application, simply run:</p> <pre><code>make fresh\n</code></pre> <p>After a short moment, the application will offer:</p> <ul> <li>http://localhost:8080/mcp: application MCP server (Streamable HTTP)</li> <li>http://localhost:8081: application core dashboard</li> <li>http://localhost:6274: MCP inspector</li> <li>http://localhost:16686: jaeger UI</li> </ul>"},{"location":"demos/mcp-application/#interact-with-the-application","title":"Interact with the application","text":""},{"location":"demos/mcp-application/#mcp-inspector","title":"MCP inspector","text":"<p>You can use the provided MCP Inspector, available on http://localhost:6274.</p> <p>To connect to the MCP server, use:</p> <ul> <li><code>Streamable HTTP</code> as transport type</li> <li><code>http://mcp-demo-app:8080/mcp</code> as URL</li> </ul> <p>Then simply click <code>Connect</code>: from there, you will be able to interact with the resources, prompts and tools of the application.</p>"},{"location":"demos/mcp-application/#mcp-hosts","title":"MCP hosts","text":"<p>If you use MCP compatible applications like Cursor, or Claude desktop, you can register this application as MCP server:</p> <pre><code>{\n  \"mcpServers\": {\n    \"mcp-demo-app\": {\n      \"url\": \"http://localhost:8080/mcp\"\n    }\n  }\n}\n</code></pre> <p>Note, if you client does not support remote MCP servers, you can use a local proxy:</p> <pre><code>{\n  \"mcpServers\": {\n    \"mcp-demo-app\": {\n      \"command\": \"npx\",\n      \"args\": [\"mcp-remote\", \"http://localhost:8080/mcp\"]\n    }\n  }\n}\n</code></pre>"},{"location":"demos/worker-application/","title":"Demo - worker application","text":"<p>Yokai's showroom provides a worker demo application.</p>"},{"location":"demos/worker-application/#overview","title":"Overview","text":"<p>This worker demo application is a simple subscriber to Pub/Sub.</p> <p>It provides:</p> <ul> <li>a Yokai application container, with the worker module to offer a subscriber worker using the fxgcppubsub contrib module</li> <li>a Pub/Sub emulator container, with preconfigured topic and subscription</li> <li>a Pub/Sub emulator UI container, preconfigured to work with the emulator container</li> <li>a Jaeger container to collect the application traces</li> </ul>"},{"location":"demos/worker-application/#layout","title":"Layout","text":"<p>This demo application is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>worker/</code>: workers</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> </ul>"},{"location":"demos/worker-application/#makefile","title":"Makefile","text":"<p>This demo application provides a <code>Makefile</code>:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"demos/worker-application/#usage","title":"Usage","text":""},{"location":"demos/worker-application/#start-the-application","title":"Start the application","text":"<p>To start the application, simply run:</p> <pre><code>make fresh\n</code></pre> <p>After a short moment, the application will offer:</p> <ul> <li>http://localhost:8081: application core dashboard</li> <li>http://localhost:8680: pub/sub emulator UI</li> <li>http://localhost:16686: jaeger UI</li> </ul>"},{"location":"demos/worker-application/#message-publication","title":"Message publication","text":"<p>You can use the Pub/Sub emulator UI to publish a message to the preconfigured topic:</p> <p>http://localhost:8680/project/demo-project/topic/demo-topic</p>"},{"location":"demos/worker-application/#message-subscription","title":"Message subscription","text":"<p>Check your application logs by running:</p> <pre><code>make logs\n</code></pre> <p>You will see the SubscribeWorker subscribed to Pub/Sub in action, logging the received messages.</p>"},{"location":"getting-started/grpc-application/","title":"Getting started - gRPC application","text":"<p>Yokai provides a ready to use gRPC application template to start your gRPC projects.</p>"},{"location":"getting-started/grpc-application/#overview","title":"Overview","text":"<p>The gRPC application template provides:</p> <ul> <li>a ready to extend Yokai application, with the gRPC server module installed</li> <li>a ready to use dev environment, based on Air (for live reloading)</li> <li>a ready to use Dockerfile for production</li> <li>some examples of service and test to get started</li> </ul>"},{"location":"getting-started/grpc-application/#layout","title":"Layout","text":"<p>This template is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>service/</code>: gRPC service and test examples</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> <li><code>proto/</code>: protobuf definition and stubs</li> </ul>"},{"location":"getting-started/grpc-application/#makefile","title":"Makefile","text":"<p>This template provides a Makefile:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake stubs  # generate gRPC stubs with protoc (ex: make stubs from=proto/example.proto)\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"getting-started/grpc-application/#installation","title":"Installation","text":""},{"location":"getting-started/grpc-application/#with-github","title":"With GitHub","text":"<p>You can create your repository using the GitHub template.</p> <p>It will automatically rename your project resources, this operation can take a few minutes.</p> <p>Once ready, after cloning and going into your repository, simply run:</p> <pre><code>make fresh\n</code></pre>"},{"location":"getting-started/grpc-application/#with-gonew","title":"With gonew","text":"<p>You can install gonew, and simply run:</p> <pre><code>gonew github.com/ankorstore/yokai-grpc-template github.com/foo/bar\ncd bar\nmake fresh\n</code></pre>"},{"location":"getting-started/grpc-application/#usage","title":"Usage","text":"<p>Once ready, the application will be available on:</p> <ul> <li><code>localhost:50051</code> for the application gRPC server</li> <li>http://localhost:8081 for the application core dashboard</li> </ul> <p>If you update the proto definition, you can run <code>make stubs from=proto/example.proto</code> to regenerate the stubs.</p> <p>Usage examples with gRPCurl:</p> <ul> <li>with <code>ExampleService/ExampleUnary</code>:</li> </ul> <pre><code>grpcurl -plaintext -d '{\"text\":\"hello\"}' localhost:50051 example.ExampleService/ExampleUnary\n{\n  \"text\": \"response from grpc-app: you sent hello\"\n}\n</code></pre> <ul> <li>with <code>ExampleService/ExampleStreaming</code>:</li> </ul> <pre><code>grpcurl -plaintext -d '@' localhost:50051 example.ExampleService/ExampleStreaming &lt;&lt;EOF\n{\"text\":\"hello\"}\n{\"text\":\"world\"}\nEOF\n{\n  \"text\": \"response from grpc-app: you sent hello\"\n}\n{\n  \"text\": \"response from grpc-app: you sent world\"\n}\n</code></pre> <p>You can use any gRPC clients, for example Postman or Evans.</p>"},{"location":"getting-started/grpc-application/#going-further","title":"Going further","text":"<p>To go further, you can:</p> <ul> <li>check the gRPC server module documentation to learn more about its features</li> <li>follow the gPRC application tutorial to create, step by step, a gRPC application</li> <li>test the gPRC demo application to see all this in action</li> </ul>"},{"location":"getting-started/http-application/","title":"Getting started - HTTP application","text":"<p>Yokai provides a ready to use HTTP application template to start your HTTP projects.</p>"},{"location":"getting-started/http-application/#overview","title":"Overview","text":"<p>The HTTP application template provides:</p> <ul> <li>a ready to extend Yokai application, with the HTTP server module installed</li> <li>a ready to use dev environment, based on Air (for live reloading)</li> <li>a ready to use Dockerfile for production</li> <li>some examples of handler and test to get started</li> </ul>"},{"location":"getting-started/http-application/#layout","title":"Layout","text":"<p>This template is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>handler/</code>: HTTP handler and test examples</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> <li><code>router.go</code>: routing registration</li> </ul> </li> </ul>"},{"location":"getting-started/http-application/#makefile","title":"Makefile","text":"<p>This template provides a Makefile:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"getting-started/http-application/#installation","title":"Installation","text":""},{"location":"getting-started/http-application/#with-github","title":"With GitHub","text":"<p>You can create your repository using the GitHub template.</p> <p>It will automatically rename your project resources, this operation can take a few minutes.</p> <p>Once ready, after cloning and going into your repository, simply run:</p> <pre><code>make fresh\n</code></pre>"},{"location":"getting-started/http-application/#with-gonew","title":"With gonew","text":"<p>You can install gonew, and simply run:</p> <pre><code>gonew github.com/ankorstore/yokai-http-template github.com/foo/bar\ncd bar\nmake fresh\n</code></pre>"},{"location":"getting-started/http-application/#usage","title":"Usage","text":"<p>Once ready, the application will be available on:</p> <ul> <li>http://localhost:8080 for the application HTTP server</li> <li>http://localhost:8081 for the application core dashboard</li> </ul>"},{"location":"getting-started/http-application/#going-further","title":"Going further","text":"<p>To go further, you can:</p> <ul> <li>check the HTTP server module documentation to learn more about its features</li> <li>follow the HTTP application tutorial to create, step by step, an HTTP application</li> <li>test the HTTP demo application to see all this in action</li> </ul>"},{"location":"getting-started/mcp-application/","title":"Getting started - MCP application","text":"<p>Yokai provides a ready to use MCP server application template to start your MCP projects.</p>"},{"location":"getting-started/mcp-application/#overview","title":"Overview","text":"<p>The MCP server application template  provides:</p> <ul> <li>a ready to extend Yokai application, with the MCP server module installed</li> <li>a ready to use dev environment, based on Air (for live reloading)</li> <li>a ready to use Dockerfile for production</li> <li>some examples of MCP tool and test to get started</li> </ul>"},{"location":"getting-started/mcp-application/#layout","title":"Layout","text":"<p>This template is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>tool/</code>: MCP tool and test examples</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> </ul>"},{"location":"getting-started/mcp-application/#makefile","title":"Makefile","text":"<p>This template provides a Makefile:</p> <pre><code>make up      # start the docker compose stack\nmake down    # stop the docker compose stack\nmake logs    # stream the docker compose stack logs\nmake fresh   # refresh the docker compose stack\nmake test    # run tests\nmake lint    # run linter\n</code></pre>"},{"location":"getting-started/mcp-application/#installation","title":"Installation","text":""},{"location":"getting-started/mcp-application/#with-github","title":"With GitHub","text":"<p>You can create your repository using the GitHub template.</p> <p>It will automatically rename your project resources, this operation can take a few minutes.</p> <p>Once ready, after cloning and going into your repository, simply run:</p> <pre><code>make fresh\n</code></pre>"},{"location":"getting-started/mcp-application/#with-gonew","title":"With gonew","text":"<p>You can install gonew, and simply run:</p> <pre><code>gonew github.com/ankorstore/yokai-mcp-template github.com/foo/bar\ncd bar\nmake fresh\n</code></pre>"},{"location":"getting-started/mcp-application/#usage","title":"Usage","text":"<p>Once ready, the application will be available on:</p> <ul> <li>http://localhost:8080/sse for the application MCP server</li> <li>http://localhost:8081 for the application core dashboard</li> </ul>"},{"location":"getting-started/mcp-application/#going-further","title":"Going further","text":"<p>To go further, you can:</p> <ul> <li>check the MCP server module documentation to learn more about its features</li> <li>follow the MCP application tutorial to create, step by step, an MCP server application</li> <li>test the MCP demo application to see all this in action</li> </ul>"},{"location":"getting-started/worker-application/","title":"Getting started - worker application","text":"<p>Yokai provides a ready to use worker application template to start your worker projects.</p>"},{"location":"getting-started/worker-application/#overview","title":"Overview","text":"<p>The worker application template provides:</p> <ul> <li>a ready to extend Yokai application, with the worker module installed</li> <li>a ready to use dev environment, based on Air (for live reloading)</li> <li>a ready to use Dockerfile for production</li> <li>some examples of worker and test to get started</li> </ul>"},{"location":"getting-started/worker-application/#layout","title":"Layout","text":"<p>This template is following the recommended project layout:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>worker/</code>: worker and test examples</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> </ul>"},{"location":"getting-started/worker-application/#makefile","title":"Makefile","text":"<p>This template provides a Makefile:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"getting-started/worker-application/#installation","title":"Installation","text":""},{"location":"getting-started/worker-application/#with-github","title":"With GitHub","text":"<p>You can create your repository using the GitHub template.</p> <p>It will automatically rename your project resources, this operation can take a few minutes.</p> <p>Once ready, after cloning and going into your repository, simply run:</p> <pre><code>make fresh\n</code></pre>"},{"location":"getting-started/worker-application/#with-gonew","title":"With gonew","text":"<p>You can install gonew, and simply run:</p> <pre><code>gonew github.com/ankorstore/yokai-worker-template github.com/foo/bar\ncd bar\nmake fresh\n</code></pre>"},{"location":"getting-started/worker-application/#usage","title":"Usage","text":"<p>Once ready, the application core dashboard will be available on http://localhost:8081.</p> <p>To see the provided example worker in action, simply run:</p> <pre><code>make logs\n</code></pre>"},{"location":"getting-started/worker-application/#going-further","title":"Going further","text":"<p>To go further, you can:</p> <ul> <li>check the worker module documentation to learn more about its features</li> <li>follow the worker application tutorial to create, step by step, a worker application</li> <li>test the worker demo application to see all this in action</li> </ul>"},{"location":"modules/fxclock/","title":"Clock Module","text":""},{"location":"modules/fxclock/#overview","title":"Overview","text":"<p>Yokai provides a fxclock module, that you can use to control time.</p> <p>It wraps the clockwork module.</p>"},{"location":"modules/fxclock/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxclock\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxclock\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxclock.FxClockModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxclock/#usage","title":"Usage","text":"<p>This module provides a clockwork.Clock instance, ready to inject in your code.</p> <p>This is particularly useful if you need to control time (set time, fast-forward, ...).</p> <p>For example:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"github.com/jonboulle/clockwork\"\n)\n\ntype ExampleService struct {\n    clock clockwork.Clock\n}\n\nfunc NewExampleService(clock clockwork.Clock) *ExampleService {\n    return &amp;ExampleService{\n        clock: clock,\n    }\n}\n\nfunc (s *ExampleService) Now() string {\n    return s.clock.Now().String()\n}\n</code></pre> <p>See the underlying vendor documentation for more details.</p>"},{"location":"modules/fxclock/#testing","title":"Testing","text":"<p>This module provides a *clockwork.FakeClock instance, that will be automatically injected as <code>clockwork.Clock</code> in your constructors in <code>test</code> mode.</p>"},{"location":"modules/fxclock/#global-time","title":"Global time","text":"<p>By default, the fake clock is set to <code>time.Now()</code> (your test execution time).</p> <p>You can configure the global time in your test in your testing configuration file (for all your tests), in RFC3339 format:</p> configs/config_test.yaml<pre><code>modules:\n  clock:\n    test:\n      time: \"2006-01-02T15:04:05Z07:00\" # time in RFC3339 format\n</code></pre> <p>You can also override this value, per test, by setting the <code>MODULES_CLOCK_TEST_TIME</code> env var.</p>"},{"location":"modules/fxclock/#time-control","title":"Time control","text":"<p>You can <code>populate</code> the *clockwork.FakeClock from your test to control time:</p> internal/service/example_test.go<pre><code>package service_test\n\nimport (\n    \"testing\"\n    \"time\"\n\n    \"github.com/ankorstore/yokai/fxsql\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/jonboulle/clockwork\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExampleService(t *testing.T) {\n    testTime := \"2025-03-30T12:00:00Z\"\n    expectedTime, err := time.Parse(time.RFC3339, testTime)\n    assert.NoError(t, err)\n\n    t.Setenv(\"MODULES_CLOCK_TEST_TIME\", testTime)\n\n    var svc service.ExampleService\n    var clock *clockwork.FakeClock\n\n    internal.RunTest(t, fx.Populate(&amp;svc, &amp;clock))\n\n    // current time as configured above\n    assert.Equal(t, expectedTime, svc.Now()) // 2025-03-30T12:00:00Z\n\n    clock.Advance(5 * time.Hour)\n\n    // current time is now advanced by 5 hours\n    assert.Equal(t, expectedTime.Add(5*time.Hour), svc.Now()) // 2025-03-30T17:00:00Z\n}\n</code></pre> <p>See tests example for more details.</p>"},{"location":"modules/fxconfig/","title":"Config Module","text":""},{"location":"modules/fxconfig/#overview","title":"Overview","text":"<p>Yokai provides a fxconfig module, allowing to define and retrieve configurations for your application.</p> <p>It wraps the config module, based on Viper.</p>"},{"location":"modules/fxconfig/#installation","title":"Installation","text":"<p>The fxconfig module is automatically loaded by Yokai's core.</p> <p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxconfig/#configuration-files","title":"Configuration files","text":"<p>By default, the module expects the configuration files:</p> <ul> <li>to be present in the <code>./configs</code> directory of your project</li> <li>to be named <code>config.{format}</code> (ex: <code>config.yaml</code>, <code>config.json</code>, etc.)</li> <li>to offer env overrides files named <code>config.{env}.{format}</code> based on the env var <code>APP_ENV</code> (ex: <code>config.test.yaml</code> if   env var <code>APP_ENV=test</code>)</li> </ul> <p>Supported configuration files formats: <code>.json</code>, <code>.toml</code>, <code>.yaml</code>, <code>.hcl</code>, <code>.ini</code>, and <code>.env</code>.</p>"},{"location":"modules/fxconfig/#usage","title":"Usage","text":"<p>For the following examples, we will be considering those configuration files:</p> configs/config.yaml<pre><code>app:\n  name: app\n  description: app description\n  env: dev\n  version: 0.1.0\n  debug: false\nconfig:\n  values:\n    string_value: default\n    int_value: 0\n  placeholder: foo-${BAR}-baz\n  substitution: foo\n</code></pre> <p>and</p> configs/config.test.yaml<pre><code>app:\n  env: test\n  debug: true\nconfig:\n  values:\n    string_value: test\n</code></pre>"},{"location":"modules/fxconfig/#configuration-access","title":"Configuration access","text":"<p>This module makes available the Config in Yokai dependency injection system.</p> <p>It is built on top of <code>Viper</code>, see its documentation for more details about available methods.</p> <p>To access it, you just need to inject it where needed, for example:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"fmt\"\n\n    \"github.com/ankorstore/yokai/config\"\n)\n\ntype ExampleService struct {\n    config *config.Config\n}\n\nfunc NewExampleService(config *config.Config) *ExampleService {\n    return &amp;ExampleService{\n        config: config,\n    }\n}\n\nfunc (s *ExampleService) PrintConfig() {\n    // helpers\n    fmt.Printf(\"name: %s\", s.config.AppName())               // name: app\n    fmt.Printf(\"description: %s\", s.config.AppDescription()) // description: app description\n    fmt.Printf(\"env: %s\", s.config.AppEnv())                 // env: dev\n    fmt.Printf(\"version: %s\", s.config.AppVersion())         // version: 0.1.0\n    fmt.Printf(\"debug: %v\", s.config.AppDebug())             // debug: false\n\n    // others\n    fmt.Printf(\"string_value: %s\", s.config.GetString(\"config.values.string_value\")) // string_value: default\n    fmt.Printf(\"int_value: %s\", s.config.GetInt(\"config.values.int_value\"))          // int_value: 0\n}\n</code></pre>"},{"location":"modules/fxconfig/#dynamic-env-overrides","title":"Dynamic env overrides","text":"<p>This module offers the possibility to override dynamically (by merging) configuration files depending on the env var <code>APP_ENV</code> value.</p> <p>For example, if <code>APP_ENV=test</code>, the module will use <code>config.yaml</code> values and merge / override them with <code>config.test.yaml</code> values.</p> <p>If you run your application in <code>test</code> mode:</p> internal/service/example.go<pre><code>// helpers\nfmt.Printf(\"var: %s\", s.config.GetEnvVar(\"APP_ENV\")) // var: test\n\nfmt.Printf(\"name: %s\", s.config.AppName())               // name: app\nfmt.Printf(\"description: %s\", s.config.AppDescription()) // description: app description\nfmt.Printf(\"env: %s\", s.config.AppEnv())                 // env: test\nfmt.Printf(\"version: %s\", s.config.AppVersion())         // version: 0.1.0\nfmt.Printf(\"debug: %v\", s.config.AppDebug())             // debug: true\n\n// others\nfmt.Printf(\"string_value: %s\", s.config.GetString(\"config.values.string_value\")) // string_value: test\nfmt.Printf(\"int_value: %s\", s.config.GetInt(\"config.values.int_value\"))          // int_value: 0\n</code></pre> <p>You can use any value for <code>APP_ENV</code>, to reflect your own environments names.</p> <p>For example if <code>APP_ENV=custom</code>, the module will use <code>config.yaml</code> values and override them with <code>config.custom.yaml</code> values.</p> <p>You just need to ensure that <code>config.custom.yaml</code> exists.</p>"},{"location":"modules/fxconfig/#env-var-placeholders","title":"Env var placeholders","text":"<p>This module offers the possibility to use placeholders in the config files to reference an env var value, that will be resolved at runtime.</p> <p>Placeholder pattern: <code>${ENV_VAR_NAME}</code>.</p> <p>For example, with the env var <code>BAR=bar</code>:</p> internal/service/example.go<pre><code>// placeholder: foo-bar-baz\nfmt.Printf(\"placeholder: %s\", s.config.GetString(\"config.placeholder\"))\n</code></pre>"},{"location":"modules/fxconfig/#env-var-substitution","title":"Env var substitution","text":"<p>This module offers the possibility to perform configuration files values substitution from env var values.</p> <p>For example, if you have a configuration key <code>config.substitution=foo</code>, providing the env var <code>CONFIG_SUBSTITUTION=bar</code> will override the value from <code>foo</code> to <code>bar</code>.</p> internal/service/example.go<pre><code>// substitution: bar\nfmt.Printf(\"substitution: %s\", cfg.GetString(\"config.substitution\")) \n</code></pre>"},{"location":"modules/fxcore/","title":"Core Module","text":""},{"location":"modules/fxcore/#overview","title":"Overview","text":"<p>Yokai provides a fxcore module, the <code>heart of your applications</code>.</p> <p>It comes with:</p> <ul> <li>a bootstrapper</li> <li>a dependency injection system, based on Fx</li> <li>a dedicated core HTTP server</li> <li>pre-enabled config, health check, log, trace, metrics and generate modules</li> <li>an extension system for Yokai <code>built-in</code>, contrib or your <code>own</code> modules</li> </ul> <p>The <code>core HTTP server</code> runs automatically on a dedicated port (default <code>8081</code>), to serve:</p> <ul> <li>the dashboard: UI to get an overview of your application</li> <li>the debug endpoints: to expose information about your build, config, loaded modules, etc.</li> <li>the health check endpoints: to expose the configured health check probes of your application</li> <li>the metrics endpoint: to expose all collected metrics from your application</li> </ul> <p>Whatever your type of application (HTTP, gRPC, worker, etc.), all <code>platform concerns</code> are handled by this dedicated server:</p> <ul> <li>to avoid to expose sensitive information (health checks, metrics, debug, etc.) to your users</li> <li>and most importantly to enable your application to focus on its logic</li> </ul>"},{"location":"modules/fxcore/#installation","title":"Installation","text":"<p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxcore/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  core:\n    server:\n      expose: true                     # to expose the core http server, disabled by default\n      address: \":8081\"                 # core http server listener address (default :8081)\n      errors:              \n        obfuscate: false               # to obfuscate error messages on the core http server responses\n        stack: false                   # to add error stack trace to error response of the core http server\n      dashboard:\n        enabled: true                  # to enable the core dashboard\n        overview:      \n          app_description: true        # to display the app description on the dashboard overview\n          app_env: true                # to display the app env on the dashboard overview\n          app_debug: true              # to display the app debug on the dashboard overview\n          app_version: true            # to display the app version on the dashboard overview\n          log_level: true              # to display the log level on the dashboard overview\n          log_output: true             # to display the log output on the dashboard overview\n          trace_sampler: true          # to display the trace sampler on the dashboard overview\n          trace_processor: true        # to display the trace processor on the dashboard overview\n      log:\n        headers:                       # to log incoming request headers on the core http server\n          x-foo: foo                   # to log for example the header x-foo in the log field foo\n          x-bar: bar              \n        exclude:                       # to exclude specific routes from logging\n          - /healthz\n          - /livez\n          - /readyz\n          - /metrics\n        level_from_response: true      # to use response status code for log level (ex: 500=error)\n      trace:     \n        enabled: true                  # to trace incoming request headers on the core http server\n        exclude:                       # to exclude specific routes from tracing\n          - /healthz     \n          - /livez     \n          - /readyz     \n          - /metrics     \n      metrics:     \n        expose: true                   # to expose metrics route, disabled by default\n        path: /metrics                 # metrics route path (default /metrics)\n        collect:       \n          enabled: true                # to collect core http server metrics, disabled by default\n          namespace: foo               # core http server metrics namespace (empty by default)\n        buckets: 0.1, 1, 10            # to override default request duration buckets\n        normalize:\n          request_path: true           # to normalize http request path, disabled by default\n          response_status: true        # to normalize http response status code (2xx, 3xx, ...), disabled by default\n      healthcheck:\n        startup:\n          expose: true                 # to expose health check startup route, disabled by default\n          path: /healthz               # health check startup route path (default /healthz)\n        readiness:            \n          expose: true                 # to expose health check readiness route, disabled by default\n          path: /readyz                # health check readiness route path (default /readyz)\n        liveness:            \n          expose: true                 # to expose health check liveness route, disabled by default\n          path: /livez                 # health check liveness route path (default /livez)\n      tasks:\n        expose: true                   # to expose tasks route, disabled by default\n        path: /tasks/:name             # tasks route path (default /tasks/:name)  \n      debug:\n        config:\n          expose: true                 # to expose debug config route\n          path: /debug/config          # debug config route path (default /debug/config)\n        pprof:\n          expose: true                 # to expose debug pprof route\n          path: /debug/pprof           # debug pprof route path (default /debug/pprof)\n        routes:\n          expose: true                 # to expose debug routes route\n          path: /debug/routes          # debug routes route path (default /debug/routes)\n        stats:\n          expose: true                 # to expose debug stats route\n          path: /debug/stats           # debug stats route path (default /debug/stats)\n        build:\n          expose: true                 # to expose debug build route\n          path: /debug/build           # debug build route path (default /debug/build)\n        modules:\n          expose: true                 # to expose debug modules route\n          path: /debug/modules/:name   # debug modules route path (default /debug/modules/:name)      \n</code></pre> <p>Notes:</p> <ul> <li>the core HTTP server requests logging will be based on the log module configuration</li> <li>the core HTTP server requests tracing will be based on the trace module configuration</li> <li>if <code>app.debug=true</code> (or env var <code>APP_DEBUG=true</code>):<ul> <li>the dashboard will be automatically enabled</li> <li>all the debug endpoints will be automatically exposed</li> <li>error responses will not be obfuscated and stack trace will be added</li> </ul> </li> </ul>"},{"location":"modules/fxcore/#usage","title":"Usage","text":""},{"location":"modules/fxcore/#bootstrap","title":"Bootstrap","text":"<p>When you use a Yokai application template, a <code>internal/bootstrap.go</code> file is provided.</p> <p>This is where you can:</p> <ul> <li>load Yokai <code>built-in</code>, contrib or your <code>own</code> modules</li> <li>configure the application with any <code>fx.Option</code>, at bootstrap on runtime</li> </ul> <p>Example of bootstrap loading the HTTP server module:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"go.uber.org/fx\"\n)\n\nfunc init() {\n    RootDir = fxcore.RootDir(1)\n}\n\n// RootDir is the application root directory.\nvar RootDir string\n\n// Bootstrapper can be used to load modules, options, dependencies, routing and bootstraps your application.\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxhttpserver.FxHttpServerModule,\n    // dependencies registration\n    Register(),\n    // routing registration\n    Router(),\n\n)\n\n// Run starts the application, with a provided [context.Context].\nfunc Run(ctx context.Context) {\n    Bootstrapper.WithContext(ctx).RunApp()\n}\n\n// RunTest starts the application in test mode, with an optional list of [fx.Option].\nfunc RunTest(tb testing.TB, options ...fx.Option) {\n    tb.Helper()\n\n    tb.Setenv(\"APP_CONFIG_PATH\", fmt.Sprintf(\"%s/configs\", RootDir))\n\n    Bootstrapper.RunTestApp(tb, fx.Options(options...))\n}\n</code></pre> <p>Notes:</p> <ul> <li>the <code>Run()</code> function is used to start your application.</li> <li>the <code>RunTest()</code> function can be used in your tests, to start your application in test mode</li> </ul>"},{"location":"modules/fxcore/#dependency-injection","title":"Dependency injection","text":"<p>Yokai is built on top of Fx, offering a simple yet powerful <code>dependency injection system</code>.</p> <p>This means you don't have to worry about injecting dependencies to your structs, your just need to register their constructors, and Yokai will automatically autowire them at runtime.</p> <p>For example, if you create an <code>ExampleService</code> that has the *config.Config as dependency:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"fmt\"\n\n    \"github.com/ankorstore/yokai/config\"\n)\n\ntype ExampleService struct {\n    config *config.Config\n}\n\nfunc NewExampleService(config *config.Config) *ExampleService {\n    return &amp;ExampleService{\n        config: config,\n    }\n}\n\nfunc (s *ExampleService) PrintAppName() {\n    fmt.Printf(\"name: %s\", s.config.AppName())\n}\n</code></pre> <p>You then need to register it, by providing its constructor in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/foo/bar/internal/service\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleService\n        fx.Provide(service.NewExampleService),\n        // ...\n    )\n}\n</code></pre> <p>This will make the <code>ExampleService</code> available in Yokai's dependency injection system, with its dependency on <code>*config.Config</code> autowired.</p> <p>The <code>ExampleService</code> will also be available for injection in any constructor depending on it.</p>"},{"location":"modules/fxcore/#dashboard","title":"Dashboard","text":"<p>If <code>modules.core.server.dashboard=true</code>, the core dashboard is available on the port <code>8081</code>:</p> <p> </p> <p>Since it's served on a dedicated port, you can safely decide to leave it enabled on production, to not expose it to the public, and access it via port forward.</p>"},{"location":"modules/fxcore/#core","title":"Core","text":"<p>The <code>Core</code> section of the dashboard offers you information about:</p> <ul> <li><code>Build</code>: environment and Go information about your application</li> <li><code>Config</code>: resolved configuration</li> <li><code>Metrics</code>: exposed metrics</li> <li><code>Routes</code>: routes of the core dashboard</li> <li><code>Pprof</code>: pprof page</li> <li><code>Stats</code>: statistics page</li> </ul>"},{"location":"modules/fxcore/#health-check","title":"Health Check","text":"<p>The <code>Healthcheck</code> section of the dashboard offers you the possibility to trigger the health check endpoints, depending on their configuration.</p> <p>You must ensure the health checks are exposed:</p> configs/config.yaml<pre><code>modules:\n  core:\n    server:\n      healthcheck:\n        startup:\n          expose: true    # to expose health check startup route, disabled by default\n          path: /healthz  # health check startup route path (default /healthz)\n        readiness:\n          expose: true    # to expose health check readiness route, disabled by default\n          path: /readyz   # health check readiness route path (default /readyz)\n        liveness:\n          expose: true    # to expose health check liveness route, disabled by default\n          path: /livez    # health check liveness route path (default /livez)\n</code></pre> <p>See the Health Check module documentation for more information.</p>"},{"location":"modules/fxcore/#tasks","title":"Tasks","text":"<p>If you need to execute one shot / private operations (like flush a cache, trigger an export, etc.) but don't want to expose an endpoint or a command for this, you can create a task.</p> <p>Yokai will collect them, and make them available in the core dashboard interface, under the <code>Tasks</code> section.</p> <p>This is particularly useful for admin / maintenance purposes, without exposing those to your end users.</p> <p>First, you must ensure the tasks are exposed:</p> configs/config.yaml<pre><code>modules:\n  core:\n    server:\n      tasks:\n        expose: true       # to expose tasks route, disabled by default\n        path: /tasks/:name # tasks route path (default /tasks/:name)  \n</code></pre> <p>Then, provide a Task implementation:</p> internal/tasks/example.go<pre><code>package tasks\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/fxcore\"\n)\n\nvar _ fxcore.Task = (*ExampleTask)(nil)\n\ntype ExampleTask struct {\n    config *config.Config\n}\n\nfunc NewExampleTask(config *config.Config) *ExampleTask {\n    return &amp;ExampleTask{\n        config: config,\n    }\n}\n\nfunc (t *ExampleTask) Name() string {\n    return \"example\"\n}\n\nfunc (t *ExampleTask) Run(ctx context.Context, input []byte) fxcore.TaskResult {\n    return fxcore.TaskResult{\n        Success: true,                     // task execution status\n        Message: \"example message\",        // task execution message\n        Details: map[string]any{           // optional task execution details\n            \"app\":   t.config.AppName(),\n            \"input\": string(input),\n        },\n    }\n}\n</code></pre> <p>Then, register the task with <code>AsTask()</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/foo/bar/internal/tasks\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleTask (will auto wire dependencies)\n        fxcore.AsTask(tasks.NewExampleTask),\n        // ...\n    )\n}\n</code></pre> <p>Note: you can also use <code>AsTasks()</code> to register several tasks at once.</p> <p>It'll be then available on the core dashboard for execution:</p> <p> </p>"},{"location":"modules/fxcore/#modules","title":"Modules","text":"<p>The <code>Modules</code> section of the dashboard offers you the possibility to check the details of the modules exposing information to the core.</p> <p>If you want your module to expose information in this section, you can provide a FxModuleInfo implementation:</p> internal/info.go<pre><code>package internal\n\ntype ExampleModuleInfo struct {}\n\nfunc (i *ExampleModuleInfo) Name() string {\n  return \"example\"\n}\n\nfunc (i *ExampleModuleInfo) Data() map[string]any {\n  return map[string]any{\n    \"example\": \"value\",\n  }\n}\n</code></pre> <p>and then register it in the <code>core-module-infos</code> group:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleModuleInfo in the core dashboard\n        fx.Provide(\n            fx.Annotate(\n              ExampleModuleInfo,\n              fx.As(new(interface{})),\n              fx.ResultTags(`group:\"core-module-infos\"`),\n            ),\n          ),\n        // ...\n    )\n}\n</code></pre> <p>See example.</p>"},{"location":"modules/fxcore/#testing","title":"Testing","text":"<p>You can start your application in test mode, with the <code>RunTest()</code> function provided in the bootstrapper.</p> <p>This wil automatically set the env var <code>APP_ENV=test</code>, and merge your test config.</p> <p>It accepts a list of <code>fx.Option</code>, for example:</p> <ul> <li><code>fx.Populate()</code> to extract from the test application autowired components for your tests</li> <li><code>fx.Invoke()</code> to execute a function at runtime</li> <li><code>fx.Decorate()</code> to override components</li> <li><code>fx.Replace()</code> to replace components</li> <li>etc.</li> </ul> <p>Test example with <code>fx.Populate()</code> :</p> internal/example_test.go<pre><code>package internal_test\n\nimport (\n    \"testing\"\n\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExample(t *testing.T) {\n    var exampleService *service.ExampleService\n\n    // run app in test mode and extract the ExampleService\n    internal.RunTest(t, fx.Populate(&amp;exampleService))\n\n    // assertion example\n    assert.Equal(t, \"foo\", exampleService.Foo())\n}\n</code></pre> <p>See Fx documentation for the available <code>fx.Option</code>.</p>"},{"location":"modules/fxcron/","title":"Cron Module","text":""},{"location":"modules/fxcron/#overview","title":"Overview","text":"<p>Yokai provides a fxcron module, providing a cron jobs scheduler to your application.</p> <p>It wraps the gocron module.</p> <p>It comes with:</p> <ul> <li>automatic panic recovery</li> <li>configurable cron jobs scheduling and execution options</li> <li>configurable logging, tracing and metrics for cron jobs executions</li> </ul>"},{"location":"modules/fxcron/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxcron\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxcron\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxcron.FxCronModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxcron/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  cron:\n    scheduler:\n      seconds: true                   # to allow seconds based cron jobs expressions (impact all jobs), disabled by default\n      concurrency:\n        limit:\n          enabled: true               # to limit concurrent cron jobs executions, disabled by default\n          max: 3                      # concurrency limit\n          mode: wait                  # \"wait\" or \"reschedule\"\n      stop:\n        timeout: 5s                   # scheduler shutdown timeout for graceful cron jobs termination, 10 seconds by default\n    jobs:                             # common cron jobs options\n      execution:\n        start:\n          immediately: true           # to start cron jobs executions immediately (by default)\n          at: \"2023-01-01T14:00:00Z\"  # or a given date time (RFC3339)\n        limit:\n          enabled: true               # to limit the number of per cron jobs executions, disabled by default\n          max: 3                      # executions limit\n      singleton:\n        enabled: true                 # to execute the cron jobs in singleton mode, disabled by default\n        mode: wait                    # \"wait\" or \"reschedule\"\n    log:\n      enabled: true                   # to log cron jobs executions, disabled by default (errors will always be logged).\n      exclude:                        # to exclude by name cron jobs from logging\n        - foo\n        - bar\n    metrics:\n      collect:\n        enabled: true                 # to collect cron jobs executions metrics (executions count and duration), disabled by default\n        namespace: foo                # cron jobs metrics namespace (empty by default)\n        subsystem: bar                # cron jobs metrics subsystem (empty by default)\n      buckets: 1, 1.5, 10, 15, 100    # to define custom cron jobs executions durations metric buckets (in seconds)\n    trace:\n      enabled: true                   # to trace cron jobs executions, disabled by default\n      exclude:                        # to exclude by name cron jobs from tracing\n        - foo\n        - bar\n</code></pre>"},{"location":"modules/fxcron/#usage","title":"Usage","text":"<p>This module provides the possibility to register CronJob implementations, with:</p> <ul> <li>a cron expression</li> <li>and an optional list of JobOption.</li> </ul> <p>They will be collected and given by Yokai to the Scheduler in its dependency injection system.</p>"},{"location":"modules/fxcron/#cron-jobs-creation","title":"Cron jobs creation","text":"<p>You can create your cron jobs by implementing the CronJob interface.</p> <p>For example:</p> internal/cron/example.go<pre><code>package cron\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/fxcron\"\n)\n\ntype ExampleCronJob struct {\n    config *config.Config\n}\n\nfunc NewExampleCronJob(config *config.Config) *ExampleCronJob {\n    return &amp;ExampleCronJob{\n        config: config,\n    }\n}\n\nfunc (c *ExampleCronJob) Name() string {\n    return \"example-cron-job\"\n}\n\nfunc (c *ExampleCronJob) Run(ctx context.Context) error {\n    // contextual job name and execution id\n    name, id := fxcron.CtxCronJobName(ctx), fxcron.CtxCronJobExecutionId(ctx)\n\n    // contextual tracing\n    ctx, span := fxcron.CtxTracer(ctx).Start(ctx, \"example span\")\n    defer span.End()\n\n    // contextual logging\n    fxcron.CtxLogger(ctx).Info().Msg(\"example log from app:%s, job:%s, id:%s\", c.config.AppName(), name, id)\n\n    // returned errors will automatically be logged\n    return nil\n}\n</code></pre> <p>You can access from the provided context:</p> <ul> <li>the cron job name with <code>CtxCronJobName()</code></li> <li>the cron job execution id with <code>CtxCronJobExecutionId()</code></li> <li>the tracer with <code>CtxTracer()</code>, which will automatically add to your spans the <code>CronJob</code> name   and <code>CronJobExecutionID</code> attributes</li> <li>the logger with <code>CtxLogger()</code>, which will automatically add to your log records the <code>cronJob</code> name   and <code>cronJobExecutionID</code> fields</li> </ul>"},{"location":"modules/fxcron/#cron-jobs-registration","title":"Cron jobs registration","text":"<p>You can register your cron jobs with the <code>AsCronJob()</code> function in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcron\"\n    \"github.com/foo/bar/cron\"\n    \"github.com/go-co-op/gocron/v2\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        fxcron.AsCronJob(\n            cron.NewExampleCronJob,        // register the ExampleCronJob\n            `*/2 * * * *`,                 // to run every 2 minutes\n            gocron.WithLimitedRuns(10),    // and with 10 max runs \n        ),\n        // ...\n    )\n}\n</code></pre> <p>This module also supports the definition of cron expression on <code>seconds</code> level with <code>modules.cron.scheduler.seconds=true</code>.</p> <p>It will add <code>seconds</code> field to the beginning of the scheduling expression, for example, to run every 3 seconds:</p> <pre><code>fxcron.AsCronJob(cron.NewExampleCronJob, `*/3 * * * * *`),\n</code></pre> <p>You can use https://crontab.guru for building you cron expressions.</p>"},{"location":"modules/fxcron/#cron-jobs-execution","title":"Cron jobs execution","text":"<p>Yokai will automatically start the Scheduler with the registered cron jobs.</p> <p>You can get, in real time, the status of your cron jobs on the core dashboard:</p> <p> </p>"},{"location":"modules/fxcron/#logging","title":"Logging","text":"<p>To get logs correlation in your cron jobs, you need to retrieve the logger from the context with <code>log.CtxLogger()</code>:</p> <pre><code>log.CtxLogger(ctx).Info().Msg(\"example message\")\n</code></pre> <p>You can also use the shortcut function <code>fxcron.CtxLogger()</code>:</p> <pre><code>fxcron.CtxLogger(ctx)\n</code></pre> <p>As a result, log records will have the <code>cronJob</code> name and <code>cronJobExecutionID</code> fields added automatically:</p> <pre><code>INF job execution success cronJob=example-cron-job cronJobExecutionID=507a78d2-b466-445c-a113-9a3a89f6fbc7 service=app system=cron\n</code></pre> <p>The cron jobs logging will be based on the log module configuration.</p>"},{"location":"modules/fxcron/#tracing","title":"Tracing","text":"<p>To get traces correlation in your cron jobs, you need to retrieve the tracer provider from the context with <code>trace.CtxTracerProvider()</code>:</p> <pre><code>ctx, span := trace.CtxTracerProvider(ctx).Tracer(\"example tracer\").Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>You can also use the shortcut function <code>fxcron.CtxTracer()</code>:</p> <pre><code>ctx, span := fxcron.CtxTracer(ctx).Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>service.name: app\nCronJob: example-cron-job\nCronJobExecutionID: 507a78d2-b466-445c-a113-9a3a89f6fbc7\n...\n</code></pre> <p>The cron jobs tracing will be based on the trace module configuration.</p>"},{"location":"modules/fxcron/#metrics","title":"Metrics","text":"<p>You can enable cron jobs automatic metrics with <code>modules.cron.metrics.collect.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  cron:\n    metrics:\n      collect:\n        enabled: true                 # to collect cron jobs executions metrics (executions count and duration), disabled by default\n        namespace: foo                # cron jobs metrics namespace (empty by default)\n        subsystem: bar                # cron jobs metrics subsystem (empty by default)\n      buckets: 1, 1.5, 10, 15, 100    # to define custom cron jobs executions durations metric buckets (in seconds)\n</code></pre> <p>This will collect metrics about:</p> <ul> <li>cron job successes</li> <li>cron job failures</li> <li>cron job execution durations</li> </ul> <p>For example, after starting Yokai's cron jobs scheduler, the core HTTP server will expose in the configured metrics endpoint:</p> [GET] /metrics<pre><code># ...\n# HELP cron_execution_duration_seconds Duration of cron job executions in seconds\n# TYPE cron_execution_duration_seconds histogram\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.001\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.002\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.005\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.01\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.02\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.05\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.1\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.2\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"0.5\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"1\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"2\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"5\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"10\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"20\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"50\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"100\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"200\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"500\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"1000\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"2000\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"5000\"} 2\ncron_execution_duration_seconds_bucket{job=\"example_cron_job\",le=\"+Inf\"} 2\ncron_execution_duration_seconds_sum{job=\"example_cron_job\"} 0.000227993\ncron_execution_duration_seconds_count{job=\"example_cron_job\"} 2\n# HELP cron_execution_total Total number of cron job executions\n# TYPE cron_execution_total counter\ncron_execution_total{job=\"example_cron_job\",status=\"success\"} 2\n</code></pre>"},{"location":"modules/fxgenerate/","title":"Generate Module","text":""},{"location":"modules/fxgenerate/#overview","title":"Overview","text":"<p>Yokai provides a fxgenerate module, allowing your application to generate UUIDs.</p> <p>It wraps the generate module, based on Google UUID.</p>"},{"location":"modules/fxgenerate/#installation","title":"Installation","text":"<p>The fxgenerate module is automatically loaded by Yokai's core.</p> <p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxgenerate/#usage","title":"Usage","text":"<p>This module makes available the UuidGenerator in Yokai dependency injection system.</p> <p>It is built on top of <code>Google UUID</code>, see its documentation for more details about available methods.</p> <p>To access it, you just need to inject it where needed, for example:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"fmt\"\n\n    \"github.com/ankorstore/yokai/generate/uuid\"\n)\n\ntype ExampleService struct {\n    generator uuid.UuidGenerator\n}\n\nfunc NewExampleService(generator uuid.UuidGenerator) *ExampleService {\n    return &amp;ExampleService{\n        generator: generator,\n    }\n}\n\nfunc (s *ExampleService) DoSomething() {\n    // uuid: dcb5d8b3-4517-4957-a42c-604d11758561\n    fmt.Printf(\"uuid: %s\", s.generator.Generate())\n}\n</code></pre>"},{"location":"modules/fxgenerate/#testing","title":"Testing","text":"<p>This module provides the possibility to make the UuidGenerator generate deterministic values (for testing purposes).</p> <p>For this, you need to:</p> <ul> <li>first provide the deterministic value to be used for generation, annotated with <code>name:\"generate-test-uuid-value\"</code></li> <li>then override the <code>UuidGeneratorFactory</code> with the provided TestUuidGeneratorFactory</li> </ul> internal/service/example_test.go<pre><code>package internal_test\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/fxgenerate/fxgeneratetest/uuid\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExampleServiceDoSomething(t *testing.T) {\n    var exampleService *service.ExampleService\n\n    internal.RunTest(\n        t,\n        fx.Populate(&amp;exampleService),\n        // provide and annotate the deterministic value\n        fx.Provide(\n            fx.Annotate(\n                func() string {\n                    return \"some value\"\n                },\n                fx.ResultTags(`name:\"generate-test-uuid-value\"`),\n            ),\n        ),\n        // override the UuidGeneratorFactory with the TestUuidGeneratorFactory\n        fx.Decorate(uuid.NewFxTestUuidGeneratorFactory),\n    )\n\n    //assertion\n    assert.Equal(t, \"uuid: some value\", exampleService.DoSomething())\n}\n</code></pre>"},{"location":"modules/fxgrpcserver/","title":"gRPC Server Module","text":""},{"location":"modules/fxgrpcserver/#overview","title":"Overview","text":"<p>Yokai provides a fxgrpcserver module, offering an gRPC server to your application.</p> <p>It wraps the grpcserver module, based on gRPC-Go.</p> <p>It comes with:</p> <ul> <li>automatic panic recovery</li> <li>automatic logging and tracing (method, duration, status, ...)</li> <li>automatic metrics</li> <li>automatic healthcheck</li> <li>automatic reflection</li> <li>possibility to register gRPC server options, interceptors and services</li> </ul>"},{"location":"modules/fxgrpcserver/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxgrpcserver\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxgrpcserver\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxgrpcserver.FxGrpcServerModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxgrpcserver/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  grpc:\n    server:\n      address: \":50051\"             # gRPC server listener address (default :50051)\n      log:\n        metadata:                   # list of gRPC metadata to add to logs on top of x-request-id, empty by default\n          x-foo: foo                # to log for example the metadata x-foo in the log field foo\n          x-bar: bar\n        exclude:                    # list of gRPC methods to exclude from logging, empty by default\n          - /test.Service/Unary\n      trace:\n        enabled: true               # to trace gRPC calls, disabled by default\n        exclude:                    # list of gRPC methods to exclude from tracing, empty by default\n          - /test.Service/Bidi\n      metrics:\n        collect:\n          enabled: true             # to collect gRPC server metrics, disabled by default\n          namespace: foo            # gRPC server metrics namespace (empty by default)\n          subsystem: bar            # gRPC server metrics subsystem (empty by default)\n        buckets: 0.1, 1, 10         # to override default request duration buckets (default prometheus.DefBuckets)\n      reflection:\n        enabled: true               # to expose gRPC reflection service, disabled by default\n      healthcheck:\n        enabled: true               # to expose gRPC healthcheck service, disabled by default\n      test:\n        bufconn:\n          size: 1048576             # test gRPC bufconn size, 1024*1024 by default\n</code></pre>"},{"location":"modules/fxgrpcserver/#usage","title":"Usage","text":"<p>This module offers the possibility to easily register gRPC server options, interceptors and services.</p>"},{"location":"modules/fxgrpcserver/#server-options-registration","title":"Server options registration","text":"<p>You can use the <code>AsGrpcServerOptions()</code> function to register grpc.ServerOption on your gRPC server.</p> <p>For example:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxgrpcserver\"\n    \"go.uber.org/fx\"\n    \"google.golang.org/grpc\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // configure the server send and receive max message size\n        fxgrpcserver.AsGrpcServerOptions(\n            grpc.MaxSendMsgSize(1000),\n            grpc.MaxRecvMsgSize(1000),\n        ),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxgrpcserver/#server-interceptors-registration","title":"Server interceptors registration","text":"<p>You can create gRPC server interceptors for your gRPC server.</p> <p>You need to implement:</p> <ul> <li>the GrpcServerUnaryInterceptor interface for <code>unary</code> interceptors</li> <li>the GrpcServerStreamInterceptor interface for <code>stream</code> interceptors</li> </ul> <p>Example of <code>unary</code> interceptor:</p> internal/interceptor/unary.go<pre><code>package interceptor\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/fxgrpcserver/testdata/service\"\n    \"github.com/ankorstore/yokai/log\"\n    \"google.golang.org/grpc\"\n)\n\ntype UnaryInterceptor struct {\n    config *config.Config\n}\n\nfunc NewUnaryInterceptor(cfg *config.Config) *UnaryInterceptor {\n    return &amp;UnaryInterceptor{\n        config: cfg,\n    }\n}\n\nfunc (i *UnaryInterceptor) HandleUnary() grpc.UnaryServerInterceptor {\n    return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) {\n        log.CtxLogger(ctx).Info().Msgf(\"in unary interceptor of %s\", i.config.AppName())\n\n        return handler(ctx, req)\n    }\n}\n</code></pre> <p>Example of <code>stream</code> interceptor:</p> internal/interceptor/stream.go<pre><code>package interceptor\n\nimport (\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/fxgrpcserver/testdata/service\"\n    \"github.com/ankorstore/yokai/log\"\n    \"google.golang.org/grpc\"\n)\n\ntype StreamInterceptor struct {\n    config *config.Config\n}\n\nfunc NewStreamInterceptor(cfg *config.Config) *StreamInterceptor {\n    return &amp;StreamInterceptor{\n        config: cfg,\n    }\n}\n\nfunc (i *StreamInterceptor) HandleStream() grpc.StreamServerInterceptor {\n    return func(srv any, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n        log.CtxLogger(ss.Context()).Info().Msgf(\"in stream interceptor of %s\", i.config.AppName())\n\n        return handler(srv, ss)\n    }\n}\n</code></pre> <p>You can register your interceptors:</p> <ul> <li>with <code>AsGrpcServerUnaryInterceptor()</code> to register a <code>unary</code> interceptor</li> <li>with <code>AsGrpcServerStreamInterceptor()</code> to register a <code>stream</code> interceptor</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxgrpcserver\"\n    \"github.com/foo/bar/internal/interceptor\"\n    \"go.uber.org/fx\"\n    \"google.golang.org/grpc\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers UnaryInterceptor as server unary interceptor\n        fxgrpcserver.AsGrpcServerUnaryInterceptor(interceptor.NewUnaryInterceptor),\n        // registers StreamInterceptor as server stream interceptor\n        fxgrpcserver.AsGrpcServerStreamInterceptor(interceptor.NewStreamInterceptor),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your interceptors will be autowired.</p>"},{"location":"modules/fxgrpcserver/#server-services-registration","title":"Server services registration","text":"<p>You can use the <code>AsGrpcServerService()</code> function to register your gRPC server services and their definitions.</p> <p>For example, with the TestService, server implementation for the test.proto:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxgrpcserver\"\n    \"github.com/ankorstore/yokai/fxgrpcserver/testdata/proto\"\n    \"github.com/ankorstore/yokai/fxgrpcserver/testdata/service\"\n    \"github.com/foo/bar/internal/interceptor\"\n    \"go.uber.org/fx\"\n    \"google.golang.org/grpc\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the TestServiceServer for the proto.Service_ServiceDesc\n        fxgrpcserver.AsGrpcServerService(service.NewTestServiceServer, &amp;proto.Service_ServiceDesc),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your services will be autowired.</p>"},{"location":"modules/fxgrpcserver/#reflection","title":"Reflection","text":"<p>This module provides the possibility to enable gRPC server reflection with <code>modules.grpc.server.reflection.enabled=true</code>.</p> configs/config.yaml<pre><code>modules:\n  grpc:\n    server:\n      reflection:\n        enabled: true # to expose gRPC reflection service, disabled by default\n</code></pre> <p>Reflection usage is helpful for developing or testing your gRPC services, but it is NOT recommended for production usage (disabled by default).</p>"},{"location":"modules/fxgrpcserver/#health-check","title":"Health Check","text":"<p>This module automatically expose the GrpcHealthCheckService with <code>modules.grpc.server.healthcheck.enabled=true</code>, to offer the Check and Watch RPCs, suitable for k8s gRPC startup, readiness or liveness probes.</p> configs/config.yaml<pre><code>modules:\n  grpc:\n    server:\n      healthcheck:\n        enabled: true # to expose gRPC healthcheck service, disabled by default\n</code></pre> <p>You can use the <code>fxhealthcheck.AsCheckerProbe()</code> function to register several CheckerProbe (more details on the fxhealthcheck module documentation).</p> <p>The GrpcHealthCheckService will:</p> <ul> <li>run the <code>liveness</code> probes checks if the request service name contains <code>liveness</code> (like <code>kubernetes::liveness</code>)</li> <li>or run the <code>readiness</code> probes checks if the request service name contains <code>readiness</code> (like <code>kubernetes::readiness</code>)</li> <li>or run the <code>startup</code> probes checks otherwise</li> </ul>"},{"location":"modules/fxgrpcserver/#logging","title":"Logging","text":"<p>You can configure RPC calls automatic logging:</p> configs/config.yaml<pre><code>modules:\n  grpc:\n    server:\n      log:\n        metadata:      # list of gRPC metadata to add to logs on top of x-request-id, empty by default\n          x-foo: foo   # to log for example the metadata x-foo in the log field foo\n          x-bar: bar\n        exclude:       # list of gRPC methods to exclude from logging, empty by default\n          - /test.Service/ToExclude\n</code></pre> <p>As a result, in your application logs:</p> <pre><code>DBG grpc call start grpcMethod=/test.Service/Unary grpcType=unary requestID=77480bd0-6d7e-42ba-bf60-9a168b9d416f service=app spanID=129a13d8f496481b system=grpcserver traceID=b016d12bdef779d793f314d476aa271f\nINF grpc call success grpcCode=0 grpcDuration=\"126.745\u00b5s\" grpcMethod=/test.Service/Unary grpcStatus=OK grpcType=unary requestID=77480bd0-6d7e-42ba-bf60-9a168b9d416f service=app spanID=129a13d8f496481b system=grpcserver traceID=b016d12bdef779d793f314d476aa271f\n</code></pre> <p>If both gRPC server logging and tracing are enabled, log records will automatically have the current <code>traceID</code> and <code>spanID</code> to be able to correlate logs and trace spans.</p> <p>If a request to an excluded gRPC method fails, the gRPC server will still log for observability purposes.</p> <p>To get logs correlation in your gRPC server services, you need to retrieve the logger from the context with <code>log.CtxLogger()</code>:</p> <pre><code>log.CtxLogger(ctx).Info().Msg(\"example message\")\n</code></pre> <p>You can also use the function <code>grpcserver.CtxLogger()</code>:</p> <pre><code>grpcserver.CtxLogger(ctx).Info().Msg(\"example message\")\n</code></pre> <p>The gRPC server logging will be based on the log module configuration.</p>"},{"location":"modules/fxgrpcserver/#tracing","title":"Tracing","text":"<p>You can enable RPC calls automatic tracing with <code>modules.grpc.server.trace.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  grpc:\n    server:\n      trace:\n        enabled: true   # to trace gRPC calls, disabled by default\n        exclude:        # list of gRPC methods to exclude from tracing, empty by default\n          - /test.Service/ToExclude\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>rpc.service: test.Service\nrpc.method: Unary\nrpc.grpc.status_code: 0\n...\n</code></pre> <p>To get traces correlation in your grpc server services, you need to retrieve the tracer provider from the context with <code>trace.CtxTracerProvider()</code>:</p> <pre><code>ctx, span := trace.CtxTracerProvider(ctx).Tracer(\"example tracer\").Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>You can also use the shortcut function <code>grpcserver.CtxTracer()</code>:</p> <pre><code>ctx, span := grpcserver.CtxTracer(ctx).Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>The gRPC server tracing will be based on the trace module configuration.</p>"},{"location":"modules/fxgrpcserver/#metrics","title":"Metrics","text":"<p>You can enable RPC calls automatic metrics with <code>modules.grpc.server.metrics.collect.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  grpc:\n    server:\n      metrics:\n        collect:\n          enabled: true          # to collect gRPC server metrics, disabled by default\n          namespace: foo         # gRPC server metrics namespace (empty by default)\n          subsystem: bar         # gRPC server metrics subsystem (empty by default)\n        buckets: 0.1, 1, 10      # to override default request duration buckets (default prometheus.DefBuckets)\n</code></pre> <p>For example, after calling <code>/test.Service/Unary</code>, the core HTTP server will expose in the configured metrics endpoint:</p> [GET] /metrics<pre><code># ...\n# HELP grpc_server_started_total Total number of RPCs started on the server.\n# TYPE grpc_server_started_total counter\ngrpc_server_started_total{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\"} 1\n# HELP grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure.\n# TYPE grpc_server_handled_total counter\nrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\"} 1\n# HELP rpc_server_msg_received_total Total number of RPC stream messages received on the server.\n# TYPE rpc_server_msg_received_total counter\ngrpc_server_msg_received_total{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\"} 1\n# HELP grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server.\n# TYPE grpc_server_msg_sent_total counter\ngrpc_server_msg_sent_total{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\"} 1\n# HELP grpc_server_handling_seconds Histogram of response latency (seconds) of gRPC that had been application-level handled by the server.\n# TYPE grpc_server_handling_seconds histogram\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.005\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.01\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.025\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.05\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.1\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.25\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"0.5\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"1\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"2.5\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"5\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"10\"} 1\ngrpc_server_handling_seconds_bucket{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\",le=\"+Inf\"} 1\ngrpc_server_handling_seconds_sum{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\"} 0.000103358\ngrpc_server_handling_seconds_count{grpc_method=\"Unary\",grpc_service=\"test.Service\",grpc_type=\"unary\"} 1\n</code></pre>"},{"location":"modules/fxgrpcserver/#testing","title":"Testing","text":"<p>This module provides a <code>*bufconn.Listener</code> that will automatically be used by the gRPC server in <code>test</code> mode.</p> <p>You can create connections for your gRPC clients, using this listener, with the TestBufconnConnectionFactory.</p> <p>You can find tests examples in the gRPC server module tests.</p>"},{"location":"modules/fxhealthcheck/","title":"Health Check Module","text":""},{"location":"modules/fxhealthcheck/#overview","title":"Overview","text":"<p>Yokai provides a fxhealthcheck module, allowing your application to provide K8s probes.</p> <p>It wraps the healthcheck module.</p>"},{"location":"modules/fxhealthcheck/#installation","title":"Installation","text":"<p>The fxhealthcheck module is automatically loaded by Yokai's core.</p> <p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxhealthcheck/#usage","title":"Usage","text":"<p>This module will enable Yokai to collect registered CheckerProbe implementations, and make them available to the Checker in its dependency injection system.</p> <p>You can register probes for <code>startup</code>, <code>liveness</code> and / or <code>readiness</code> checks.</p> <p>The check result will be considered as success if ALL registered probes checks are successful.</p> <p>Notes:</p> <ul> <li>to perform complex checks, you can inject dependencies to your probes implementation (ex: database, cache, etc)</li> <li>it is recommended to design your probes with a single responsibility (ex: one for database, one for cache, etc)</li> </ul>"},{"location":"modules/fxhealthcheck/#probes-creation","title":"Probes creation","text":"<p>You can create your probes by implementing the CheckerProbe interface.</p> <p>For example:</p> internal/probe/success.go<pre><code>package probe\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/healthcheck\"\n)\n\ntype SuccessProbe struct{}\n\nfunc NewSuccessProbe() *SuccessProbe {\n    return &amp;SuccessProbe{}\n}\n\nfunc (p *SuccessProbe) Name() string {\n    return \"successProbe\"\n}\n\nfunc (p *SuccessProbe) Check(context.Context) *healthcheck.CheckerProbeResult {\n    return healthcheck.NewCheckerProbeResult(true, \"success example message\")\n}\n</code></pre> <p>and</p> internal/probe/failure.go<pre><code>package probe\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/healthcheck\"\n)\n\ntype FailureProbe struct{}\n\nfunc NewFailureProbe() *FailureProbe {\n    return &amp;FailureProbe{}\n}\n\nfunc (p *FailureProbe) Name() string {\n    return \"failureProbe\"\n}\n\nfunc (p *FailureProbe) Check(context.Context) *healthcheck.CheckerProbeResult {\n    return healthcheck.NewCheckerProbeResult(false, \"failure example message\")\n}\n</code></pre>"},{"location":"modules/fxhealthcheck/#probes-registration","title":"Probes registration","text":"<p>You can register your probes for <code>startup</code>, <code>liveness</code> and / or <code>readiness</code> checks with the <code>AsCheckerProbe()</code> function:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/healthcheck\"\n    \"github.com/foo/bar/probe\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the SuccessProbe probe for startup, liveness and readiness checks\n        fxhealthcheck.AsCheckerProbe(probe.NewSuccessProbe),\n        // register the FailureProbe probe for liveness checks only\n        fxhealthcheck.AsCheckerProbe(probe.NewFailureProbe, healthcheck.Liveness), \n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxhealthcheck/#probes-execution","title":"Probes execution","text":"<p>Yokai's core HTTP server will automatically:</p> <ul> <li>expose the configured health check endpoints</li> <li>use the Checker to run the registered probes</li> </ul> <p>Following previous example:</p> <ul> <li>calling the <code>startup</code> endpoint will return a <code>200</code> response:</li> </ul> [GET] /healthz<pre><code>{\n    \"success\": true, \n    \"probes\": {\n        \"successProbe\": {\n            \"success\": true,\n            \"message\": \"success example message\"\n        }\n    }\n}\n</code></pre> <ul> <li>calling the <code>liveness</code> endpoint will return a <code>500</code> response:</li> </ul> [GET] /livez<pre><code>{\n    \"success\": false, \n    \"probes\": {\n        \"successProbe\": {\n            \"success\": true,\n            \"message\": \"success example message\"\n        },\n        \"failureProbe\": {\n            \"success\": false,\n            \"message\": \"failure example message\"\n        }\n    }\n}\n</code></pre> <ul> <li>calling the <code>readiness</code> endpoint will return a <code>200</code> response:</li> </ul> [GET] /readyz<pre><code>{\n    \"success\": true, \n    \"probes\": {\n        \"successProbe\": {\n            \"success\": true,\n            \"message\": \"success example message\"\n        }\n    }\n}\n</code></pre>"},{"location":"modules/fxhttpclient/","title":"HTTP Client Module","text":""},{"location":"modules/fxhttpclient/#overview","title":"Overview","text":"<p>Yokai provides a fxhttpclient module, offering a ready to use Client to your application.</p> <p>It wraps the httpclient module, based on net/http.</p>"},{"location":"modules/fxhttpclient/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxhttpclient\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxhttpclient\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxhttpclient.FxHttpClientModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxhttpclient/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  http:\n    client:\n      timeout: 30                            # in seconds, 30 by default\n      transport:\n        max_idle_connections: 100            # 100 by default\n        max_connections_per_host: 100        # 100 by default\n        max_idle_connections_per_host: 100   # 100 by default\n      log:\n        request:\n          enabled: true                      # to log request details, disabled by default\n          body: true                         # to add request body to request details, disabled by default\n          level: info                        # log level for request logging\n        response:\n          enabled: true                      # to log response details, disabled by default\n          body: true                         # to add response body to request details, disabled by default\n          level: info                        # log level for response logging\n          level_from_response: true          # to use response code for response logging\n      trace:\n        enabled: true                        # to trace http calls, disabled by default\n      metrics:\n        collect:\n          enabled: true                      # to collect http client metrics\n          namespace: foo                     # http client metrics namespace (empty by default)\n          subsystem: bar                     # http client metrics subsystem (empty by default)\n        buckets: 0.1, 1, 10                  # to override default request duration buckets\n        normalize:\n          request_path: true                 # to normalize http request path, disabled by default\n          request_path_masks:                # request path normalization masks (key: mask to apply, value: regex to match), empty by default\n            /foo/{id}/bar?page={page}: /foo/(.+)/bar\\?page=(.+)\n          response_status: true              # to normalize http response status code (2xx, 3xx, ...), disabled by default\n</code></pre>"},{"location":"modules/fxhttpclient/#usage","title":"Usage","text":"<p>This module makes available the Client in Yokai dependency injection system.</p> <p>To access it, you just need to inject it where needed, for example:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"context\"\n    \"net/http\"\n)\n\ntype ExampleService struct {\n    client *http.Client\n}\n\nfunc ExampleService(client *http.Client) *ExampleService {\n    return &amp;ExampleService{\n        client: client,\n    }\n}\n\nfunc (s *ExampleService) Call(ctx context.Context) (*http.Response, error) {\n    req, err := http.NewRequest(http.MethodGet, \"https://example.com\", nil)\n    if err != nil {\n        return nil, err\n    }\n\n    return s.client.Do(req.WithContext(ctx))\n}\n</code></pre>"},{"location":"modules/fxhttpclient/#logging","title":"Logging","text":"<p>This module enables to log automatically the HTTP requests made by the Client and their responses:</p> configs/config.yaml<pre><code>modules:\n  http:\n    client:\n      log:\n        request:\n          enabled: true              # to log request details, disabled by default\n          body: true                 # to add request body to request details, disabled by default\n          level: info                # log level for request logging\n        response:\n          enabled: true              # to log response details, disabled by default\n          body: true                 # to add response body to request details, disabled by default\n          level: info                # log level for response logging\n          level_from_response: true  # to use response code for response logging\n</code></pre> <p>If <code>modules.http.client.log.response.level_from_response=true</code>, the response code will be used to determinate the log level:</p> <ul> <li><code>code &lt; 400</code>: log level configured in <code>modules.http.client.log.response.level</code></li> <li><code>400 &lt;= code &lt; 500</code>: log level <code>warn</code></li> <li><code>code &gt;= 500</code>: log level <code>error</code></li> </ul> <p>The HTTP client logging will be based on the log module configuration.</p>"},{"location":"modules/fxhttpclient/#tracing","title":"Tracing","text":"<p>This module enables to trace automatically HTTP the requests made by the Client:</p> configs/config.yaml<pre><code>modules:\n  http:\n    client:\n      trace:\n        enabled: true # to trace http calls, disabled by default\n</code></pre> <p>The HTTP client tracing will be based on the trace module configuration.</p>"},{"location":"modules/fxhttpclient/#metrics","title":"Metrics","text":"<p>This module enables to automatically generate metrics about HTTP the requests made by the Client:</p> configs/config.yaml<pre><code>modules:\n  http:\n    client:\n      metrics:\n        collect:\n          enabled: true                      # to collect http client metrics\n          namespace: foo                     # http client metrics namespace (empty by default)\n          subsystem: bar                     # http client metrics subsystem (empty by default)\n        buckets: 0.1, 1, 10                  # to override default request duration buckets\n        normalize:\n          request_path: true                 # to normalize http request path, disabled by default\n          request_path_masks:                # request path normalization masks (key: mask to apply, value: regex to match), empty by default\n            /foo/{id}/bar?page={page}: /foo/(.+)/bar\\?page=(.+)\n          response_status: true              # to normalize http response status code (2xx, 3xx, ...), disabled by default\n</code></pre> <p>If <code>modules.http.client.metrics.normalize.request_path=true</code>, the <code>modules.http.client.metrics.normalize.request_path_masks</code> map will be used to try to apply masks on the metrics path label for better cardinality.</p> <p>In this example, after calling <code>client.Get(\"https://example.com/foo/1/bar?page=2\")</code>, the core HTTP server will expose in the configured metrics endpoint:</p> [GET] /metrics<pre><code># ...\n# HELP http_client_request_duration_seconds Time spent performing HTTP requests\n# TYPE http_client_request_duration_seconds histogram\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.005\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.01\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.025\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.05\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.1\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.25\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"0.5\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"1\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"2.5\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"5\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"10\"} 1\nhttp_client_request_duration_seconds_bucket{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\",le=\"+Inf\"} 1\nhttp_client_request_duration_seconds_sum{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\"} 0.00064455\nhttp_client_request_duration_seconds_count{method=\"GET\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\"} 1\n# HELP http_client_requests_total Number of performed HTTP requests\n# TYPE http_client_requests_total counter\nhttp_client_requests_total{method=\"GET\",status=\"2xx\",host=\"https://example.com\",path=\"/foo/{id}/bar?page={page}\"} 1\n</code></pre>"},{"location":"modules/fxhttpclient/#testing","title":"Testing","text":"<p>This module provides a httpclienttest.NewTestHTTPServer() helper for testing your clients against a test server, that allows you:</p> <ul> <li>to define test HTTP roundtrips: a couple of test aware functions to define the request and the response behavior</li> <li>to configure several test HTTP roundtrips if you need to test successive calls</li> </ul> <p>To use it:</p> internal/service/example_test.go<pre><code>package service_test\n\nimport (\n    \"net/http\"\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/httpclient\"\n    \"github.com/ankorstore/yokai/httpclient/httpclienttest\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestHTTPClient(t *testing.T) {\n    t.Parallel()\n\n    // retrieve your client\n    var client *http.Client\n\n    // test server preparation\n    testServer := httpclienttest.NewTestHTTPServer(\n        t,\n        // configures a roundtrip for the 1st client call (/foo)\n        httpclienttest.WithTestHTTPRoundTrip(\n            // func to configure / assert on the client request\n            func(tb testing.TB, req *http.Request) error {\n                tb.Helper()\n\n                // performs some assertions\n                assert.Equal(tb, \"/foo\", req.URL.Path)\n\n                // returning an error here will make the test fail, if needed\n                return nil\n            },\n            // func to configure / assert on the response for the client\n            func(tb testing.TB, w http.ResponseWriter) error {\n                tb.Helper()\n\n                // prepares the response for the client\n                w.Header.Set(\"foo\", \"bar\")\n\n                // performs some assertions\n                assert.Equal(tb, \"bar\", w.Header.Get(\"foo\"))\n\n                // returning an error here will make the test fail, if needed\n                return nil\n            },\n        ),\n        // configures a roundtrip for the 2nd client call (/bar)\n        httpclienttest.WithTestHTTPRoundTrip(\n            // func to configure / assert on the client request\n            func(tb testing.TB, req *http.Request) error {\n                tb.Helper()\n\n                assert.Equal(tb, \"/bar\", req.URL.Path)\n\n                return nil\n            },\n            // func to configure / assert on the response for the client\n            func(tb testing.TB, w http.ResponseWriter) error {\n                tb.Helper()\n\n                w.WriteHeader(http.StatusInternalServerError)\n\n                return nil\n            },\n        ),\n    )\n\n    // 1st client call (/foo)\n    resp, err := client.Get(testServer.URL + \"/foo\")\n    assert.NoError(t, err)\n    assert.Equal(t, http.StatusOK, resp.StatusCode)\n    assert.Equal(t, \"bar\", resp.Header.Get(\"foo\"))\n\n    // 2nd client call (/bar)\n    resp, err = client.Get(testServer.URL + \"/bar\")\n    assert.NoError(t, err)\n    assert.Equal(t, http.StatusInternalServerError, resp.StatusCode)\n}\n</code></pre> <p>You can find more complete examples in the module tests.</p>"},{"location":"modules/fxhttpserver/","title":"HTTP Server Module","text":""},{"location":"modules/fxhttpserver/#overview","title":"Overview","text":"<p>Yokai provides a fxhttpserver module, offering an HTTP server to your application.</p> <p>It wraps the httpserver module, based on Echo.</p> <p>It comes with:</p> <ul> <li>automatic panic recovery</li> <li>automatic requests logging and tracing (method, path, duration, ...)</li> <li>automatic requests metrics (count and duration)</li> <li>possibility to register handlers, groups and middlewares</li> <li>possibility to render HTML templates</li> </ul>"},{"location":"modules/fxhttpserver/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxhttpserver\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxhttpserver.FxHttpServerModule,\n    // routing registration\n    Router(),\n    // ...\n)\n</code></pre> <p>Then create, if not existing, the <code>internal/router.go</code> file for your registrations:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options()\n}\n</code></pre> <p>It is recommended to keep routing registration separated from dependencies registration, for better maintainability. If you use the HTTP application template, this is already done for you.</p>"},{"location":"modules/fxhttpserver/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  http:\n    server:\n      address: \":8080\"            # http server listener address (default :8080)\n      errors:\n        obfuscate: false          # to obfuscate error messages on the http server responses\n        stack: false              # to add error stack trace to error response of the http server\n      log:\n        headers:                  # to log incoming request headers on the http server\n          x-foo: foo              # to log for example the header x-foo in the log field foo\n          x-bar: bar\n        exclude:                  # to exclude specific routes from logging\n          - /foo\n          - /bar\n        level_from_response: true # to use response status code for log level (ex: 500=error)\n      trace:\n        enabled: true             # to trace incoming request headers on the http server\n        exclude:                  # to exclude specific routes from tracing\n          - /foo\n          - /bar\n      metrics:\n        collect:\n          enabled: true           # to collect http server metrics\n          namespace: foo          # http server metrics namespace (empty by default)\n          subsystem: bar          # http server metrics subsystem (empty by default)\n        buckets: 0.1, 1, 10       # to override default request duration buckets\n        normalize:\n          request_path: true      # to normalize http request path, disabled by default\n          response_status: true   # to normalize http response status code (2xx, 3xx, ...), disabled by default\n      templates:\n        enabled: true             # disabled by default\n        path: templates/*.html    # templates path lookup pattern\n</code></pre> <p>If <code>app.debug=true</code> (or env var <code>APP_DEBUG=true</code>), error responses will not be obfuscated and stack trace will be added.</p>"},{"location":"modules/fxhttpserver/#usage","title":"Usage","text":"<p>This module offers the possibility to easily register HTTP handlers, groups and middlewares.</p>"},{"location":"modules/fxhttpserver/#middlewares-registration","title":"Middlewares registration","text":"<p>You can use the <code>AsMiddleware()</code> function to register global middlewares on your HTTP server:</p> <ul> <li>any Middleware implementation</li> <li>or any <code>echo.MiddlewareFunc</code>, for example Echo built-in middlewares</li> </ul> <p>For example, you can create a middleware:</p> internal/middleware/example.go<pre><code>package middleware\n\nimport (\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/httpserver\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype ExampleMiddleware struct {\n    config *config.Config\n}\n\nfunc NewExampleMiddleware(config *config.Config) *ExampleMiddleware {\n    return &amp;ExampleMiddleware{\n        config: config,\n    }\n}\n\nfunc (m *ExampleMiddleware) Handle() echo.MiddlewareFunc {\n    return func(next echo.HandlerFunc) echo.HandlerFunc {\n        return func(c echo.Context) error {\n            // example of correlated log\n            log.CtxLogger(c.Request().Context()).Info().Msg(\"in example middleware\")\n\n            // injected dependency example usage\n            c.Response().Header().Add(\"app-name\", m.config.AppName())\n\n            return next(c)\n        }\n    }\n}\n</code></pre> <p>You can then register your middlewares:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"github.com/foo/bar/internal/middleware\"\n    echomiddleware \"github.com/labstack/echo/v4/middleware\"\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options(\n        // registers the Echo CORS middleware via echo.Use()\n        fxhttpserver.AsMiddleware(echomiddleware.CORS(), fxhttpserver.GlobalUse),\n        // registers and autowire the ExampleMiddleware via echo.Pre()\n        fxhttpserver.AsMiddleware(middleware.NewExampleMiddleware, fxhttpserver.GlobalPre), \n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxhttpserver/#handlers-registration","title":"Handlers registration","text":"<p>You can use the <code>AsHandler()</code> function to register handlers and their middlewares on your HTTP server:</p> <ul> <li>any Handler implementation</li> <li>or any <code>echo.HandlerFunc</code></li> </ul> <p>For example, you can create a handler:</p> internal/handler/example.go<pre><code>package handler\n\nimport (\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/httpserver\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype ExampleHandler struct {\n    config *config.Config\n}\n\nfunc NewExampleHandler(config *config.Config) *ExampleHandler {\n    return &amp;ExampleHandler{\n        config: config,\n    }\n}\n\nfunc (h *ExampleHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        // example of correlated trace span\n        ctx, span := trace.CtxTracerProvider(c.Request().Context()).Tracer(\"example tracer\").Start(c.Request().Context(), \"example span\")\n        defer span.End()\n\n        // example of correlated log\n        log.CtxLogger(ctx).Info().Msg(\"in example handler\")\n\n        // injected dependency example usage\n        return c.String(http.StatusOK, fmt.Sprintf(\"app name: %s\", h.config.AppName()))\n    }\n}\n</code></pre> <p>You can then register it:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"github.com/foo/bar/internal/handler\"\n    \"github.com/foo/bar/internal/middleware\"\n    echomiddleware \"github.com/labstack/echo/v4/middleware\"\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options(\n        // registers and autowire the ExampleHandler for [GET] /example, with the ExampleMiddleware and Echo CORS() middlewares\n        fxhttpserver.AsHandler(\"GET\", \"/example\", handler.NewExampleHandler, middleware.NewExampleMiddleware, echomiddleware.CORS()),\n        // ...\n    )\n}\n</code></pre> <p>Notes:</p> <ul> <li>you can specify several valid HTTP methods (comma separated) while registering a handler, for example <code>fxhttpserver.AsHandler(\"GET,POST\", ...)</code></li> <li>you can use the shortcut <code>*</code> to register a handler for all valid HTTP methods, for example <code>fxhttpserver.AsHandler(\"*\", ...)</code></li> <li>the valid HTTP methods are <code>CONNECT</code>, <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, <code>PUT</code>, <code>TRACE</code>, <code>PROPFIND</code> and <code>REPORT</code></li> </ul>"},{"location":"modules/fxhttpserver/#handlers-groups-registration","title":"Handlers groups registration","text":"<p>You can use the <code>AsHandlersGroup()</code> function to register handlers groups and their middlewares on your HTTP server:</p> <ul> <li>any Handler implementation or any <code>echo.HandlerFunc</code>, with their middlewares</li> <li>and group them<ul> <li>under a common route <code>prefix</code></li> <li>with common any Middleware implementations or any <code>echo.MiddlewareFunc</code></li> </ul> </li> </ul> <p>For example, you can create another handler:</p> internal/handler/other.go<pre><code>package handler\n\nimport (\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/httpserver\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype OtherHandler struct {\n    config *config.Config\n}\n\nfunc NewOtherHandler(config *config.Config) *OtherHandler {\n    return &amp;OtherHandler{\n        config: config,\n    }\n}\n\nfunc (h *OtherHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        // example of correlated trace span\n        ctx, span := trace.CtxTracerProvider(c.Request().Context()).Tracer(\"example tracer\").Start(c.Request().Context(), \"other span\")\n        defer span.End()\n\n        // example of correlated log\n        log.CtxLogger(ctx).Info().Msg(\"in other handler\")\n\n        // injected dependency example usage\n        return c.String(http.StatusOK, fmt.Sprintf(\"app name: %s\", h.config.AppName()))\n    }\n}\n</code></pre> <p>You can then register your handlers in a group:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"github.com/foo/bar/internal/handler\"\n    \"github.com/foo/bar/internal/middleware\"\n    echomiddleware \"github.com/labstack/echo/v4/middleware\"\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options(\n        fxhttpserver.AsHandlersGroup(\n            // common route prefix\n            \"/group\",\n            []*fxhttpserver.HandlerRegistration{\n                // registers and autowire the ExampleHandler for [GET] /group/example, with the ExampleMiddleware\n                fxhttpserver.NewHandlerRegistration(\"GET\", \"/example\", handler.NewExampleHandler, middleware.NewExampleMiddleware),\n                // registers and autowire the OtherHandler for [GET] /group/other, with the Echo CORS middleware\n                fxhttpserver.NewHandlerRegistration(\"GET\", \"/other\", handler.NewOtherHandler, echomiddleware.CORS()),\n            },\n            // common Echo CSRF middleware, applied to both handlers\n            echomiddleware.CSRF(),\n        ),\n        // ...\n    )\n}\n</code></pre> <p>Notes:</p> <ul> <li>you can specify several valid HTTP methods (comma separated) while registering a handler in a group, for example <code>fxhttpserver.NewHandlerRegistration(\"GET,POST\", ...)</code></li> <li>you can use the shortcut <code>*</code> to register a handler for all valid HTTP methods, for example <code>fxhttpserver.NewHandlerRegistration(\"*\", ...)</code></li> <li>the valid HTTP methods are <code>CONNECT</code>, <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, <code>PUT</code>, <code>TRACE</code>, <code>PROPFIND</code> and <code>REPORT</code></li> </ul>"},{"location":"modules/fxhttpserver/#error-handler-registration","title":"Error handler registration","text":"<p>You can use the <code>AsErrorHandler()</code> function to register a custom error handler on your HTTP server.</p> <p>It can be any ErrorHandler implementation.</p> <p>For example, you can create an error handler:</p> internal/errorhandler/example.go<pre><code>package errorhandler\n\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype ExampleErrorHandler struct {\n    config *config.Config\n}\n\nfunc NewExampleErrorHandler(config *config.Config) *ExampleErrorHandler {\n    return &amp;ExampleErrorHandler{\n        config: config,\n    }\n}\n\nfunc (h *ExampleErrorHandler) Handle() echo.HTTPErrorHandler {\n    return func(err error, c echo.Context) {\n        if c.Response().Committed {\n            return\n        }\n\n        c.String(http.StatusInternalServerError, fmt.Sprintf(\"error handled in example error handler of %s: %s\", h.config.AppName(), err))\n    }\n}\n</code></pre> <p>You can then register your error handler:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"github.com/foo/bar/internal/errorhandler\"\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options(\n        // registers the ExampleErrorHandler as error handler\n        fxhttpserver.AsErrorHandler(errorhandler.NewExampleErrorHandler),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxhttpserver/#websocket","title":"WebSocket","text":"<p>This module supports the <code>WebSocket</code> protocol, see the Echo documentation for more information.</p>"},{"location":"modules/fxhttpserver/#templates","title":"Templates","text":"<p>The module will look up HTML templates to render if <code>modules.http.server.templates.enabled=true</code>.</p> <p>The HTML templates will be loaded from a path matching the pattern specified in <code>modules.http.server.templates.path</code>.</p> <p>For example, considering the following configuration:</p> configs/config.yaml<pre><code>app:\n  name: app\nmodules:\n  http:\n    server:\n      templates:\n        enabled: true\n        path: templates/*.html\n</code></pre> <p>And the following template:</p> templates/app.html<pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;App name is {{index . \"name\"}}&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>You can then render it from your handler, with the <code>Render()</code> function:</p> internal/handler/template.go<pre><code>package handler\n\nimport (\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/httpserver\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n    \"github.com/labstack/echo/v4\"\n    \"go.uber.org/fx\"\n)\n\ntype TemplateHandler struct {\n    config *config.Config\n}\n\nfunc NewTemplateHandler(cfg *config.Config) *TemplateHandler {\n    return &amp;TemplateHandler{\n        config: cfg,\n    }\n}\n\nfunc (h *TemplateHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        // will render: \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;App name is app&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n        return c.Render(http.StatusOK, \"app.html\", map[string]interface{}{\n            \"name\": h.config.AppName(),\n        })\n    }\n}\n</code></pre>"},{"location":"modules/fxhttpserver/#logging","title":"Logging","text":"<p>You can configure HTTP requests automatic logging:</p> configs/config.yaml<pre><code>modules:\n  http:\n    server:\n      log:\n        headers:                  # to log incoming request headers on the http server\n          x-foo: foo              # to log for example the header x-foo in the log field foo\n          x-bar: bar\n        exclude:                  # to exclude specific routes from logging\n          - /foo\n          - /bar\n        level_from_response: true # to use response status code for log level (ex: 500=error)\n</code></pre> <p>As a result, in your application logs:</p> <pre><code>INT service=app example message requestID=0f507e36-ea56-4842-b2f5-a53467e227e5 spanID=950c48301f39d2e3 traceID=d69d972b00302ec3e5369c8d439c4fac\nINF service=app request logger latency=\"12.34\u00b5s\" method=GET uri=/example status=200 module=httpserver requestID=0f507e36-ea56-4842-b2f5-a53467e227e5 spanID=950c48301f39d2e3 traceID=d69d972b00302ec3e5369c8d439c4fac\n</code></pre> <p>If both HTTP server logging and tracing are enabled, log records will automatically have the current <code>traceID</code> and <code>spanID</code> to be able to correlate logs and trace spans.</p> <p>To get logs correlation in your handlers, you need to retrieve the logger from the context with <code>log.CtxLogger()</code>:</p> <pre><code>log.CtxLogger(c.Request().Context()).Info().Msg(\"example message\")\n</code></pre> <p>You can also use the shortcut function <code>httpserver.CtxLogger()</code> to work with Echo context:</p> <pre><code>httpserver.CtxLogger(c).Info().Msg(\"example message\")\n</code></pre> <p>The HTTP server logging will be based on the log module configuration.</p>"},{"location":"modules/fxhttpserver/#tracing","title":"Tracing","text":"<p>You can enable HTTP requests automatic tracing with <code>modules.http.server.trace.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  http:\n    server:\n      trace:\n        enabled: true # to trace incoming request headers on the http server\n        exclude:      # to exclude specific routes from tracing\n          - /foo\n          - /bar\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>service.name: app\nhttp.method: GET\nhttp.route: /example\nhttp.status_code: 200\n...\n</code></pre> <p>To get traces correlation in your handlers, you need to retrieve the tracer provider from the context with <code>trace.CtxTracerProvider()</code>:</p> <pre><code>ctx := c.Request().Context()\nctx, span := trace.CtxTracerProvider(ctx).Tracer(\"example tracer\").Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>You can also use the shortcut function <code>httpserver.CtxTracer()</code> to work with Echo context:</p> <pre><code>ctx, span := httpserver.CtxTracer(c).Start(c.Request().Context(), \"example span\")\ndefer span.End()\n</code></pre> <p>The HTTP server tracing will be based on the fxtrace module configuration.</p>"},{"location":"modules/fxhttpserver/#metrics","title":"Metrics","text":"<p>You can enable HTTP requests automatic metrics with <code>modules.http.server.metrics.collect.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  http:\n    server:\n      metrics:\n        collect:\n          enabled: true          # to collect http server metrics\n          namespace: foo         # http server metrics namespace (empty by default)\n          subsystem: bar         # http server metrics subsystem (empty by default)\n        buckets: 0.1, 1, 10      # to override default request duration buckets\n        normalize:\n          request_path: true     # to normalize http request path, disabled by default\n          response_status: true  # to normalize http response status code (2xx, 3xx, ...), disabled by default\n</code></pre> <p>For example, after calling <code>[GET] /example</code>, the core HTTP server will expose in the configured metrics endpoint:</p> [GET] /metrics<pre><code># ...\n# HELP http_server_request_duration_seconds Time spent processing HTTP requests\n# TYPE http_server_request_duration_seconds histogram\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.005\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.01\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.025\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.05\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.1\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.25\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"0.5\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"1\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"2.5\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"5\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"10\"} 1\nhttp_server_request_duration_seconds_bucket{path=\"/example\",method=\"GET\",le=\"+Inf\"} 1\nhttp_server_request_duration_seconds_sum{path=\"/\",method=\"GET\"} 0.0014433150000000001\n# HELP http_server_requests_total Number of processed HTTP requests\n# TYPE http_server_requests_total counter\nhttp_server_requests_total{path=\"/example\",method=\"GET\",status=\"2xx\"} 1\n</code></pre> <p>Regarding metrics normalization, if you register for example a handler:</p> <ul> <li>with <code>fxhttpserver.AsHandler(\"GET\", \"/foo/bar/:id\", handler.NewExampleHandler)</code></li> <li>that returns <code>200</code> as response code</li> </ul> <p>And receive requests on <code>/foo/bar/baz?page=1</code>:</p> <ul> <li>if <code>modules.http.server.metrics.normalize.request_path=true</code>, the metrics <code>path</code> label will be <code>/foo/bar/:id</code>, otherwise it'll be <code>/foo/bar/baz?page=1</code></li> <li>if <code>modules.http.server.metrics.normalize.response_status=true</code>, the metrics <code>status</code> label will be <code>2xx</code>, otherwise it'll be <code>200</code></li> </ul>"},{"location":"modules/fxhttpserver/#testing","title":"Testing","text":"<p>This module provides the possibility to perform functional testing, by calling your application endpoints from your tests.</p> <p>You can easily assert on:</p> <ul> <li>HTTP responses</li> <li>logs</li> <li>traces</li> <li>metrics</li> </ul> <p>For example, if you want to test the ExampleHandler:</p> internal/handler/example_test.go<pre><code>package handler_test\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/log/logtest\"\n    \"github.com/ankorstore/yokai/trace/tracetest\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/testutil\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.opentelemetry.io/otel/attribute\"\n    semconv \"go.opentelemetry.io/otel/semconv/v1.20.0\"\n    \"go.opentelemetry.io/otel/trace\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExampleHandler(t *testing.T) {\n    var httpServer *echo.Echo\n    var logBuffer logtest.TestLogBuffer\n    var traceExporter tracetest.TestTraceExporter\n    var metricsRegistry *prometheus.Registry\n\n    internal.RunTest(t, fx.Populate(&amp;httpServer, &amp;logBuffer, &amp;traceExporter, &amp;metricsRegistry))\n\n    // call [GET] /example\n    req := httptest.NewRequest(http.MethodGet, \"/example\", nil)\n    rec := httptest.NewRecorder()\n    httpServer.ServeHTTP(rec, req)\n\n    // HTTP response example\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Equal(t, rec.Body.String(), \"app name: app\")\n\n    // logs assertion example\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":   \"info\",\n        \"service\": \"app\",\n        \"message\": \"in example handler\",\n    })\n\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":   \"info\",\n        \"service\": \"app\",\n        \"module\":  \"httpserver\",\n        \"method\":  \"GET\",\n        \"uri\":     \"/example\",\n        \"status\":  http.StatusOK,\n        \"message\": \"request logger\",\n    })\n\n    // traces assertion example\n    tracetest.AssertHasTraceSpan(\n        t,\n        traceExporter,\n        \"example span\",\n    )\n\n    tracetest.AssertHasTraceSpan(\n        t,\n        traceExporter,\n        \"GET /example\",\n        semconv.HTTPRoute(\"/test\"),\n        semconv.HTTPMethod(http.MethodGet),\n        semconv.HTTPStatusCode(http.StatusOK),\n    )\n\n    // metrics assertion example\n    expectedMetric := `\n        # HELP http_server_requests_total Number of processed HTTP requests\n        # TYPE http_server_requests_total counter\n        http_server_requests_total{handler=\"/example\",method=\"GET\",status=\"2xx\"} 1\n    `\n\n    err := testutil.GatherAndCompare(\n        metricsRegistry,\n        strings.NewReader(expectedMetric),\n        \"http_server_requests_total\",\n    )\n    assert.NoError(t, err)\n}\n</code></pre>"},{"location":"modules/fxlog/","title":"Log Module","text":""},{"location":"modules/fxlog/#overview","title":"Overview","text":"<p>Yokai provides a fxlog module, allowing your application to produce logs.</p> <p>It wraps the log module, based on Zerolog.</p>"},{"location":"modules/fxlog/#installation","title":"Installation","text":"<p>The fxlog module is automatically loaded by Yokai's core.</p> <p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxlog/#configuration","title":"Configuration","text":"<p>This module provides the possibility to configure:</p> <ul> <li>the <code>log level</code> (possible values: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>fatal</code>, <code>panic</code>, <code>no-level</code> or <code>disabled</code>)</li> <li>the <code>log output</code> (possible values: <code>noop</code>, <code>stdout</code> or <code>test</code>)</li> </ul> <p>Regarding the output:</p> <ul> <li><code>stdout</code>: to send the log records to <code>os.Stdout</code> (default)</li> <li><code>noop</code>: to void the log records via <code>os.Discard</code></li> <li><code>console</code>: pretty prints logs record to <code>os.Stdout</code></li> <li><code>test</code>: to send the log records to the TestLogBuffer made available in the Fx container, for further assertions</li> </ul> configs/config.yaml<pre><code>modules:\n  log:\n    level: info    # by default\n    output: stdout # by default\n</code></pre>"},{"location":"modules/fxlog/#usage","title":"Usage","text":"<p>This module makes available the Logger in Yokai dependency injection system.</p> <p>It is built on top of <code>Zerolog</code>, see its documentation for more details about available methods.</p> <p>You can inject the logger where needed, but it's recommended to use the one carried by the <code>context.Context</code> when possible (for automatic logs correlation).</p>"},{"location":"modules/fxlog/#testing","title":"Testing","text":"<p>This module provides the possibility to easily test your application logs, using the TestLogBuffer with <code>modules.log.output=test</code>.</p> configs/config.test.yaml<pre><code>modules:\n  log:\n    output: test # to send logs to test buffer\n</code></pre> <p>You can use the provided test assertion helpers in your tests:</p> <ul> <li><code>AssertHasLogRecord</code>: to assert on exact attributes match</li> <li><code>AssertHasNotLogRecord</code>: to assert on exact attributes non match</li> <li><code>AssertContainLogRecord</code>: to assert on partial attributes match</li> <li><code>AssertContainNotLogRecord</code>: to assert on partial attributes non match</li> </ul> <p>and use <code>Dump()</code> to print the current content of the TestLogBuffer.</p> <p>For example:</p> internal/example_test.go<pre><code>package internal_test\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/log/logtest\"\n    \"github.com/foo/bar/internal\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExample(t *testing.T) {\n    var logBuffer logtest.TestLogBuffer\n\n    internal.RunTest(\n        t,\n        fx.Populate(&amp;logBuffer),\n        fx.Invoke(func(logger *log.Logger) {\n            logger.Debug().Msg(\"test message\")\n        }),\n    )\n\n    // print logs records\n    logBuffer.Dump()\n\n    // log assertion example\n    logtest.AssertHasLogRecord(\n        t,\n        logBuffer,\n        map[string]interface{}{\n            \"level\":   \"debug\",\n            \"message\": \"test message\",\n        }, \n    )\n}\n</code></pre>"},{"location":"modules/fxmcpserver/","title":"MCP Server Module","text":""},{"location":"modules/fxmcpserver/#overview","title":"Overview","text":"<p>Yokai provides a fxmcpserver module, offering an MCP server to your application.</p> <p>It wraps the mark3labs/mcp-go module.</p> <p>It comes with:</p> <ul> <li>automatic panic recovery</li> <li>automatic requests logging and tracing (method, target, duration, ...)</li> <li>automatic requests metrics (count and duration)</li> <li>possibility to register MCP resources, resource templates, prompts and tools</li> <li>possibility to register MCP Streamable HTTP and SSE server context hooks</li> <li>possibility to expose the MCP server via Streamable HTTP (remote), HTTP SSE (remote) and Stdio (local)</li> </ul>"},{"location":"modules/fxmcpserver/#installation","title":"Installation","text":"<p>First, install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxmcpserver\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxmcpserver.FxMCPServerModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxmcpserver/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      name: \"MCP Server\"                  # server name (\"MCP server\" by default)\n      version: 1.0.0                      # server version (1.0.0 by default)\n      capabilities:\n        resources: true                   # to expose MCP resources and resource templates (disabled by default)\n        prompts: true                     # to expose MCP prompts (disabled by default)\n        tools: true                       # to expose MCP tools (disabled by default)\n      transport:\n        stream:\n          expose: true                    # to remotely expose the MCP server via Streamable HTTP (disabled by default)\n          address: \":8083\"                # exposition address (\":8083\" by default)\n          stateless: false                # stateless server mode (disabled by default)\n          base_path: \"/mcp\"               # base path (\"/mcp\" by default)\n          keep_alive: true                # to keep the connections alive\n          keep_alive_interval: 10         # keep alive interval in seconds (10 by default)\n        sse:\n          expose: true                    # to remotely expose the MCP server via SSE (disabled by default)\n          address: \":8082\"                # exposition address (\":8082\" by default)\n          base_url: \"\"                    # base url (\"\" by default)\n          base_path: \"\"                   # base path (\"\" by default)\n          sse_endpoint: \"/sse\"            # SSE endpoint (\"/sse\" by default)\n          message_endpoint: \"/message\"    # message endpoint (\"/message\" by default)\n          keep_alive: true                # to keep connection alive\n          keep_alive_interval: 10         # keep alive interval in seconds (10 by default)\n        stdio:\n          expose: true                   # to locally expose the MCP server via Stdio (disabled by default)\n      log:\n        request: true                     # to log MCP requests contents (disabled by default)\n        response: true                    # to log MCP responses contents (disabled by default)\n      trace:\n        request: true                     # to trace MCP requests contents (disabled by default)\n        response: true                    # to trace MCP responses contents (disabled by default)\n      metrics:\n        collect:\n          enabled: true                   # to collect MCP server metrics (disabled by default)\n          namespace: foo                  # MCP server metrics namespace (\"\" by default)\n          subsystem: bar                  # MCP server metrics subsystem (\"\" by default)\n        buckets: 0.1, 1, 10               # to override default request duration buckets\n</code></pre>"},{"location":"modules/fxmcpserver/#usage","title":"Usage","text":"<p>This module offers the possibility to easily register MCP resources, resource templates, prompts and tools.</p>"},{"location":"modules/fxmcpserver/#resources-registration","title":"Resources registration","text":"<p>This module offers an MCPServerResource interface to implement to provide an MCP resource.</p> <p>For example, an MCP resource that reads a file path coming from the configuration:</p> internal/mcp/resource/readme.go<pre><code>package resource\n\nimport (\n    \"context\"\n    \"os\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\ntype ReadmeResource struct {\n    config *config.Config\n}\n\nfunc NewReadmeResource(config *config.Config) *ReadmeResource {\n    return &amp;ReadmeResource{\n        config: config,\n    }\n}\n\nfunc (r *ReadmeResource) Name() string {\n    return \"readme\"\n}\n\nfunc (r *ReadmeResource) URI() string {\n    return \"docs://readme\"\n}\n\nfunc (r *ReadmeResource) Options() []mcp.ResourceOption {\n    return []mcp.ResourceOption{\n        mcp.WithResourceDescription(\"Project README\"),\n    }\n}\n\nfunc (r *ReadmeResource) Handle() server.ResourceHandlerFunc {\n    return func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {\n        content, err := os.ReadFile(r.config.GetString(\"config.readme.path\"))\n        if err != nil {\n            return nil, err\n        }\n\n        return []mcp.ResourceContents{\n            mcp.TextResourceContents{\n                URI:      \"docs://readme\",\n                MIMEType: \"text/markdown\",\n                Text:     string(content),\n            },\n        }, nil\n    }\n}\n</code></pre> <p>You can register your MCP resource:</p> <ul> <li>with <code>AsMCPServerResource()</code> to register a single MCP resource</li> <li>with <code>AsMCPServerResources()</code> to register several MCP resources at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n    \"github.com/foo/bar/internal/mcp/resource\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers ReadmeResource as MCP resource\n        fxmcpserver.AsMCPServerResource(resource.NewReadmeResource),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your MCP resources will be autowired.</p> <p>To expose it, you need to ensure that the MCP server has the <code>resources</code> capability enabled:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      capabilities:\n        resources: true # to expose MCP resources &amp; resource templates (disabled by default)\n</code></pre>"},{"location":"modules/fxmcpserver/#resource-templates-registration","title":"Resource templates registration","text":"<p>This module offers an MCPServerResourceTemplate interface to implement to provide an MCP resource template.</p> <p>For example, an MCP resource template that retrieves a user profile for a given id:</p> internal/mcp/resource/readme.go<pre><code>package resource\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/foo/bar/internal/user\"\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\ntype UserProfileResource struct {\n    repository *user.Respository\n}\n\nfunc NewUserProfileResource(repository *user.Respository) *UserProfileResource {\n    return &amp;UserProfileResource{\n        repository: repository,\n    }\n}\n\nfunc (r *UserProfileResource) Name() string {\n    return \"user-profile\"\n}\n\nfunc (r *UserProfileResource) URI() string {\n    return \"users://{id}/profile\"\n}\n\nfunc (r *UserProfileResource) Options() []mcp.ResourceTemplateOption {\n    return []mcp.ResourceTemplateOption{\n        mcp.WithTemplateDescription(\"User profile\"),\n    }\n}\n\nfunc (r *UserProfileResource) Handle() server.ResourceTemplateHandlerFunc {\n    return func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {\n        // some user id extraction logic\n        userID := extractUserIDFromURI(request.Params.URI)\n\n        // find user profile by user id\n        user, err := r.repository.Find(userID)\n        if err != nil {\n            return nil, err\n        }\n\n        return []mcp.ResourceContents{\n            mcp.TextResourceContents{\n                URI:      request.Params.URI,\n                MIMEType: \"application/json\",\n                Text:     user,\n            },\n        }, nil\n    }\n}\n</code></pre> <p>You can register your MCP resource template:</p> <ul> <li>with <code>AsMCPServerResourceTemplate()</code> to register a single MCP resource template</li> <li>with <code>AsMCPServerResourceTemplates()</code> to register several MCP resource templates at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n    \"github.com/foo/bar/internal/mcp/resource\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers UserProfileResource as MCP resource template\n        fxmcpserver.AsMCPServerResourceTemplate(resource.NewUserProfileResource),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your MCP resource templates will be autowired.</p> <p>To expose it, you need to ensure that the MCP server has the <code>resources</code> capability enabled:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      capabilities:\n        resources: true # to expose MCP resources &amp; resource templates (disabled by default)\n</code></pre>"},{"location":"modules/fxmcpserver/#prompts-registration","title":"Prompts registration","text":"<p>This module offers an MCPServerPrompt interface to implement to provide an MCP prompt.</p> <p>For example, an MCP prompt that greets a provided user name:</p> internal/mcp/prompt/greet.go<pre><code>package prompt\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\ntype GreetingPrompt struct {\n    config *config.Config\n}\n\nfunc NewGreetingPrompt(config *config.Config) *GreetingPrompt {\n    return &amp;GreetingPrompt{\n        config: config,\n    }\n}\n\nfunc (p *GreetingPrompt) Name() string {\n    return \"greeting\"\n}\n\nfunc (p *GreetingPrompt) Options() []mcp.PromptOption {\n    return []mcp.PromptOption{\n        mcp.WithPromptDescription(\"A friendly greeting prompt\"),\n        mcp.WithArgument(\n            \"name\",\n            mcp.ArgumentDescription(\"Name of the person to greet\"),\n        ),\n    }\n}\n\nfunc (p *GreetingPrompt) Handle() server.PromptHandlerFunc {\n    return func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n        name := request.Params.Arguments[\"name\"]\n        if name == \"\" {\n            name = \"friend\"\n        }\n\n        return mcp.NewGetPromptResult(\n            \"A friendly greeting\",\n            []mcp.PromptMessage{\n                mcp.NewPromptMessage(\n                    mcp.RoleAssistant,\n                    mcp.NewTextContent(fmt.Sprintf(\"Hello, %s! I am %s. How can I help you today?\", name, p.config.GetString(\"config.assistant.name\"))),\n                ),\n            },\n        ), nil\n    }\n}\n</code></pre> <p>You can register your MCP prompt:</p> <ul> <li>with <code>AsMCPServerPrompt()</code> to register a single MCP prompt</li> <li>with <code>AsMCPServerPrompts()</code> to register several MCP prompts at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n    \"github.com/foo/bar/internal/mcp/prompt\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers GreetingPrompt as MCP prompt\n        fxmcpserver.AsMCPServerPrompt(prompt.NewGreetingPrompt),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your MCP prompts will be autowired.</p> <p>To expose it, you need to ensure that the MCP server has the <code>prompts</code> capability enabled:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      capabilities:\n        prompts: true # to expose MCP prompts (disabled by default)\n</code></pre>"},{"location":"modules/fxmcpserver/#tools-registration","title":"Tools registration","text":"<p>This module offers an MCPServerTool interface to implement to provide an MCP tool.</p> <p>For example, an MCP tool that performs basic arithmetic calculations:</p> internal/mcp/tool/calculator.go<pre><code>package tool\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\ntype CalculatorTool struct {\n    config *config.Config\n}\n\nfunc NewCalculatorTool(config *config.Config) *CalculatorTool {\n    return &amp;CalculatorTool{\n        config: config,\n    }\n}\n\nfunc (t *CalculatorTool) Name() string {\n    return \"calculator\"\n}\n\nfunc (t *CalculatorTool) Options() []mcp.ToolOption {\n    return []mcp.ToolOption{\n        mcp.WithDescription(\"Perform basic arithmetic calculations\"),\n        mcp.WithString(\n            \"operation\",\n            mcp.Required(),\n            mcp.Description(\"The arithmetic operation to perform\"),\n            mcp.Enum(\"add\", \"subtract\", \"multiply\", \"divide\"),\n        ),\n        mcp.WithNumber(\n            \"x\",\n            mcp.Required(),\n            mcp.Description(\"First number\"),\n        ),\n        mcp.WithNumber(\n            \"y\",\n            mcp.Required(),\n            mcp.Description(\"Second number\"),\n        ),\n    }\n}\n\nfunc (t *CalculatorTool) Handle() server.ToolHandlerFunc {\n    return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n        // correlated trace span\n        ctx, span := trace.CtxTracer(ctx).Start(ctx, \"in calculator tool\")\n        defer span.End()\n\n        // correlated log\n        log.CtxLogger(ctx).Info().Msg(\"in calculator tool\")\n\n        // calculator logic\n        if !t.config.GetBool(\"config.calculator.enabled\") {\n            return nil, fmt.Errorf(\"calculator is not enabled\")\n        }\n\n        op := request.Params.Arguments[\"operation\"].(string)\n        x := request.Params.Arguments[\"x\"].(float64)\n        y := request.Params.Arguments[\"y\"].(float64)\n\n        var result float64\n        switch op {\n        case \"add\":\n            result = x + y\n        case \"subtract\":\n            result = x - y\n        case \"multiply\":\n            result = x * y\n        case \"divide\":\n            if y == 0 {\n                return mcp.NewToolResultError(\"cannot divide by zero\"), nil\n            }\n\n            result = x / y\n        }\n\n        return mcp.FormatNumberResult(result), nil\n    }\n}\n</code></pre> <p>You can register your MCP tool:</p> <ul> <li>with <code>AsMCPServerTool()</code> to register a single MCP tool</li> <li>with <code>AsMCPServerTools()</code> to register several MCP tools at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n    \"github.com/foo/bar/internal/mcp/tool\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers CalculatorTool as MCP tool\n        fxmcpserver.AsMCPServerTool(tool.NewCalculatorTool),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your MCP tools will be autowired.</p> <p>To expose it, you need to ensure that the MCP server has the <code>tools</code> capability enabled:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      capabilities:\n        tools: true # to expose MCP tools (disabled by default)\n</code></pre>"},{"location":"modules/fxmcpserver/#hooks","title":"Hooks","text":"<p>This module provides hooking mechanisms for the <code>StreamableHTTP</code> and <code>SSE</code> servers requests handling.</p>"},{"location":"modules/fxmcpserver/#streamablehttp-server-hooks","title":"StreamableHTTP server hooks","text":"<p>This module offers the possibility to provide context hooks with MCPStreamableHTTPServerContextHook implementations, that will be applied on each MCP StreamableHTTP request.</p> <p>For example, an MCP StreamableHTTP server context hook that adds a config value to the context:</p> internal/mcp/resource/readme.go<pre><code>package hook\n\nimport (\n    \"context\"\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\ntype ExampleHook struct {\n    config *config.Config\n}\n\nfunc NewExampleHook(config *config.Config) *ExampleHook {\n    return &amp;ExampleHook{\n        config: config,\n    }\n}\n\nfunc (h *ExampleHook) Handle() server.HTTPContextFunc {\n    return func(ctx context.Context, r *http.Request) context.Context {\n        return context.WithValue(ctx, \"foo\", h.config.GetString(\"foo\"))\n    }\n}\n</code></pre> <p>You can register your MCP StreamableHTTP server context hook:</p> <ul> <li>with <code>AsMCPStreamableHTTPServerContextHook()</code> to register a single MCP StreamableHTTP server context hook</li> <li>with <code>AsMCPStreamableHTTPServerContextHooks()</code> to register several MCP StreamableHTTP server context hooks at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n    \"github.com/foo/bar/internal/mcp/hook\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers ExampleHook as MCP StreamableHTTP server context hook\n        fxmcpserver.AsMCPStreamableHTTPServerContextHook(hook.NewExampleHook),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your MCP StreamableHTTP server context hooks will be autowired.</p>"},{"location":"modules/fxmcpserver/#sse-server-hooks","title":"SSE server hooks","text":"<p>This module offers the possibility to provide context hooks with MCPSSEServerContextHook implementations, that will be applied on each MCP SSE request.</p> <p>For example, an MCP SSE server context hook that adds a config value to the context:</p> internal/mcp/resource/readme.go<pre><code>package hook\n\nimport (\n    \"context\"\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\ntype ExampleHook struct {\n    config *config.Config\n}\n\nfunc NewExampleHook(config *config.Config) *ExampleHook {\n    return &amp;ExampleHook{\n        config: config,\n    }\n}\n\nfunc (h *ExampleHook) Handle() server.SSEContextFunc {\n    return func(ctx context.Context, r *http.Request) context.Context {\n        return context.WithValue(ctx, \"foo\", h.config.GetString(\"foo\"))\n    }\n}\n</code></pre> <p>You can register your MCP SSE server context hook:</p> <ul> <li>with <code>AsMCPSSEServerContextHook()</code> to register a single MCP SSE server context hook</li> <li>with <code>AsMCPSSEServerContextHooks()</code> to register several MCP SSE server context hooks at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmcpserver\"\n    \"github.com/foo/bar/internal/mcp/hook\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // registers ExampleHook as MCP SSE server context hook\n        fxmcpserver.AsMCPSSEServerContextHook(hook.NewExampleHook),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your MCP SSE server context hooks will be autowired.</p>"},{"location":"modules/fxmcpserver/#logging","title":"Logging","text":"<p>You can configure the MCP server requests and responses automatic logging:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      log:\n        request: true   # to log MCP requests contents (disabled by default)\n        response: true  # to log MCP responses contents (disabled by default)\n</code></pre> <p>As a result, in your application logs:</p> <pre><code>INF in calculator tool mcpRequestID=460aab37-e16e-4464-9956-54fce47746e7 mcpSessionID=8f617d54-e4c9-4459-bb26-76b4d96e2b72 mcpTransport=streamable-http service=yokai-mcp spanID=0f536ffa84fb8800 system=mcpserver traceID=594a9585cbfd5362c03968cd6d7d786c\nINF MCP request success mcpLatency=4.869308ms mcpMethod=tools/call mcpRequest=\"...\" mcpResponse=\"...\" mcpRequestID=460aab37-e16e-4464-9956-54fce47746e7 mcpSessionID=8f617d54-e4c9-4459-bb26-76b4d96e2b72 mcpTool=calculator mcpTransport=streamable-http service=yokai-mcp spanID=0f536ffa84fb8800 system=mcpserver traceID=594a9585cbfd5362c03968cd6d7d786c\n</code></pre> <p>If both HTTP server logging and tracing are enabled, log records will automatically have the current <code>traceID</code> and <code>spanID</code> to be able to correlate logs and trace spans.</p> <p>To get logs correlation in your MCP registrations, you need to retrieve the logger from the context with <code>log.CtxLogger()</code>:</p> <pre><code>log.CtxLogger(c.Request().Context()).Info().Msg(\"in calculator tool\")\n</code></pre> <p>The MCP server logging will be based on the log module configuration.</p>"},{"location":"modules/fxmcpserver/#tracing","title":"Tracing","text":"<p>You can configure the MCP server requests and responses automatic tracing:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      trace:\n        request: true   # to trace MCP requests contents (disabled by default)\n        response: true  # to trace MCP responses contents (disabled by default)\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>service.name: yokai-mcp\nmcp.method: tools/call\nmcp.tool: calculator\nmcp.transport: streamable-http\nmcp.request: ...\nmcp.response: ...\n...\n</code></pre> <p>To get traces correlation in your MCP registrations, you need to retrieve the tracer from the context with <code>trace.CtxTracer()</code>:</p> <pre><code>ctx, span := trace.CtxTracer(ctx).Start(ctx, \"in calculator tool\")\ndefer span.End()\n</code></pre> <p>The MCP server tracing will be based on the fxtrace module configuration.</p>"},{"location":"modules/fxmcpserver/#metrics","title":"Metrics","text":"<p>You can enable MCP requests automatic metrics with <code>modules.mcp.server.metrics.collect.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  mcp:\n    server:\n      metrics:\n        collect:\n          enabled: true      # to collect MCP server metrics (disabled by default)\n          namespace: foo     # MCP server metrics namespace (\"\" by default)\n          subsystem: bar     # MCP server metrics subsystem (\"\" by default)\n        buckets: 0.1, 1, 10  # to override default request duration buckets\n</code></pre> <p>For example, after calling the <code>calculator</code> MCP tool, the core HTTP server will expose in the configured metrics endpoint:</p> [GET] /metrics<pre><code># ...\n# HELP mcp_server_requests_duration_seconds Time spent processing MCP requests\n# TYPE mcp_server_requests_duration_seconds histogram\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.005\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.01\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.025\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.05\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.1\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.25\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"0.5\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"1\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"2.5\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"5\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"10\"} 1\nmcp_server_requests_duration_seconds_bucket{method=\"tools/call\",target=\"calculator\",le=\"+Inf\"} 1\nmcp_server_requests_duration_seconds_sum{method=\"tools/call\",target=\"calculator\"} 0.004869308\nmcp_server_requests_duration_seconds_count{method=\"tools/call\",target=\"calculator\"} 1\n# HELP mcp_server_requests_total Number of processed MCP requests\n# TYPE mcp_server_requests_total counter\nmcp_server_requests_total{method=\"tools/call\",status=\"success\",target=\"calculator\"} 1\n</code></pre>"},{"location":"modules/fxmcpserver/#testing","title":"Testing","text":"<p>This module provide <code>StreamableHTTP</code> and <code>SSE</code> test servers, to functionally test your applications.</p>"},{"location":"modules/fxmcpserver/#streamablehttp-test-server","title":"StreamableHTTP test server","text":"<p>This module provides a MCPStreamableHTTPTestServer to enable you to easily test your exposed MCP registrations.</p> <p>From this server, you can create a ready to use client via <code>StartClient()</code> to perform MCP requests, to functionally test your MCP server.</p> <p>You can easily assert on:</p> <ul> <li>MCP responses</li> <li>logs</li> <li>traces</li> <li>metrics</li> </ul> <p>For example, to test an <code>MCP ping</code>:</p> internal/mcp/ping_test.go<pre><code>package handler_test\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/log/logtest\"\n    \"github.com/ankorstore/yokai/trace/tracetest\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/testutil\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.opentelemetry.io/otel/attribute\"\n    \"go.opentelemetry.io/otel/trace\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestMCPPing(t *testing.T) {\n    var testServer *fxmcpservertest.MCPStreamableHTTPTestServer\n    var logBuffer logtest.TestLogBuffer\n    var traceExporter tracetest.TestTraceExporter\n    var metricsRegistry *prometheus.Registry\n\n    internal.RunTest(t, fx.Populate(&amp;testServer, &amp;logBuffer, &amp;traceExporter, &amp;metricsRegistry))\n\n    // close the test server once done\n    defer testServer.Close()\n\n    // start test client\n    testClient, err := testServer.StartClient(context.Background())\n    assert.NoError(t, err)\n\n    // send MCP ping request\n    err = testClient.Ping(context.Background())\n    assert.NoError(t, err)\n\n    // assertion on the logs buffer\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":        \"info\",\n        \"mcpMethod\":    \"ping\",\n        \"mcpTransport\": \"streamable-http\",\n        \"message\":      \"MCP request success\",\n    })\n\n    // assertion on the traces exporter\n    tracetest.AssertHasTraceSpan(\n        t,\n        traceExporter,\n        \"MCP ping\",\n        attribute.String(\"mcp.method\", \"ping\"),\n        attribute.String(\"mcp.transport\", \"streamable-http\"),\n    )\n\n    // assertion on the metrics registry\n    expectedMetric := `\n        # HELP mcp_server_requests_total Number of processed MCP requests\n        # TYPE mcp_server_requests_total counter\n        mcp_server_requests_total{method=\"ping\",status=\"success\",target=\"\"} 1\n    `\n\n    err = testutil.GatherAndCompare(\n        metricsRegistry,\n        strings.NewReader(expectedMetric),\n        \"mcp_server_requests_total\",\n    )\n    assert.NoError(t, err)\n}\n</code></pre>"},{"location":"modules/fxmcpserver/#sse-test-server","title":"SSE test server","text":"<p>This module provides a MCPSSETestServer to enable you to easily test your exposed MCP registrations.</p> <p>From this server, you can create a ready to use client via <code>StartClient()</code> to perform MCP requests, to functionally test your MCP server.</p> <p>You can easily assert on:</p> <ul> <li>MCP responses</li> <li>logs</li> <li>traces</li> <li>metrics</li> </ul> <p>For example, to test an <code>MCP ping</code>:</p> internal/mcp/ping_test.go<pre><code>package handler_test\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/log/logtest\"\n    \"github.com/ankorstore/yokai/trace/tracetest\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/testutil\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.opentelemetry.io/otel/attribute\"\n    \"go.opentelemetry.io/otel/trace\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestMCPPing(t *testing.T) {\n    var testServer *fxmcpservertest.MCPSSETestServer\n    var logBuffer logtest.TestLogBuffer\n    var traceExporter tracetest.TestTraceExporter\n    var metricsRegistry *prometheus.Registry\n\n    internal.RunTest(t, fx.Populate(&amp;testServer, &amp;logBuffer, &amp;traceExporter, &amp;metricsRegistry))\n\n    // close the test server once done\n    defer testServer.Close()\n\n    // start test client\n    testClient, err := testServer.StartClient(context.Background())\n    assert.NoError(t, err)\n\n    // close the test client once done\n    defer testClient.Close()\n\n    // send MCP ping request\n    err = testClient.Ping(context.Background())\n    assert.NoError(t, err)\n\n    // assertion on the logs buffer\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":        \"info\",\n        \"mcpMethod\":    \"ping\",\n        \"mcpTransport\": \"sse\",\n        \"message\":      \"MCP request success\",\n    })\n\n    // assertion on the traces exporter\n    tracetest.AssertHasTraceSpan(\n        t,\n        traceExporter,\n        \"MCP ping\",\n        attribute.String(\"mcp.method\", \"ping\"),\n        attribute.String(\"mcp.transport\", \"sse\"),\n    )\n\n    // assertion on the metrics registry\n    expectedMetric := `\n        # HELP mcp_server_requests_total Number of processed MCP requests\n        # TYPE mcp_server_requests_total counter\n        mcp_server_requests_total{method=\"ping\",status=\"success\",target=\"\"} 1\n    `\n\n    err = testutil.GatherAndCompare(\n        metricsRegistry,\n        strings.NewReader(expectedMetric),\n        \"mcp_server_requests_total\",\n    )\n    assert.NoError(t, err)\n}\n</code></pre>"},{"location":"modules/fxmetrics/","title":"Metrics Module","text":""},{"location":"modules/fxmetrics/#overview","title":"Overview","text":"<p>Yokai provides a fxmetrics module, allowing your application to provide metrics.</p> <p>It wraps the Prometheus module.</p>"},{"location":"modules/fxmetrics/#installation","title":"Installation","text":"<p>The fxmetrics module is automatically loaded by Yokai's core.</p> <p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxmetrics/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  metrics:\n    collect:\n      build: true    # to collect build infos metrics (disabled by default)\n      go: true       # to collect go metrics (disabled by default)\n      process: true  # to collect process metrics (disabled by default)\n</code></pre>"},{"location":"modules/fxmetrics/#usage","title":"Usage","text":"<p>This module will enable Yokai to collect registered metrics collectors, and make them available to a metrics registry in its dependency injection system.</p>"},{"location":"modules/fxmetrics/#metrics-creation","title":"Metrics creation","text":"<p>You can add metrics anywhere in your application.</p> <p>For example:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"fmt\"\n\n    \"github.com/prometheus/client_golang/prometheus\"\n)\n\nvar ExampleCounter = prometheus.NewCounter(prometheus.CounterOpts{\n    Name: \"example_total\",\n    Help: \"Example counter\",\n})\n\ntype ExampleService struct {}\n\nfunc NewExampleService() *ExampleService {\n    return &amp;ExampleService{}\n}\n\nfunc (s *ExampleService) DoSomething() {\n    // service logic\n    fmt.Println(\"do something\")\n\n    // increment counter\n    ExampleCounter.Inc()\n}\n</code></pre>"},{"location":"modules/fxmetrics/#metrics-registration","title":"Metrics registration","text":"<p>Even if convenient, it's recommended to NOT use the promauto way of registering metrics, as it uses a global registry that leads to data race conditions (especially while testing).</p> <p>You can instead register your metrics collector with the <code>AsMetricsCollector()</code> function:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmetrics\"\n    \"github.com/foo/bar/internal/service\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleCounter metrics collector\n        fxmetrics.AsMetricsCollector(service.ExampleCounter),\n        // ...\n    )\n}\n</code></pre> <p>You can also register several metrics collectors at once with <code>AsMetricsCollectors()</code>.</p>"},{"location":"modules/fxmetrics/#metrics-execution","title":"Metrics execution","text":"<p>Yokai's core HTTP server will automatically:</p> <ul> <li>expose the configured metrics endpoints</li> <li>use the registry to expose the registered metrics collectors</li> </ul> <p>Following previous example, after invoking the <code>ExampleService</code>, the metrics endpoint will return:</p> [GET] /metrics<pre><code># ...\n# HELP example_total Example counter\n# TYPE example_total counter\nexample_total 1\n</code></pre> <p>You can also get, real time, the status of your metrics on the core dashboard:</p> <p> </p>"},{"location":"modules/fxorm/","title":"ORM Module","text":""},{"location":"modules/fxorm/#overview","title":"Overview","text":"<p>Yokai provides a fxorm module, allowing your application to interact with databases.</p> <p>It wraps the orm module, based on GORM.</p>"},{"location":"modules/fxorm/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxorm\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxorm\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // load fxorm module\n    fxorm.FxOrmModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxorm/#configuration","title":"Configuration","text":"<p>This module provides the possibility to configure the database <code>driver</code>:</p> <ul> <li><code>sqlite</code> for SQLite databases</li> <li><code>mysql</code> for MySQL databases</li> <li><code>postgres</code> for PostgreSQL databases</li> <li><code>sqlserver</code> for SQL Server databases</li> </ul> <p>You can also provide to the ORM the database<code>dsn</code>, some <code>config</code>, and configure SQL queries automatic <code>logging</code> and <code>tracing</code>.</p> configs/config.yaml<pre><code>modules:\n  orm:\n    driver: mysql                                               # driver to use\n    dsn: \"user:password@tcp(localhost:3306)/db?parseTime=True\"  # database DSN to use\n    config:\n      dry_run: false                                            # disabled by default\n      skip_default_transaction: false                           # disabled by default\n      full_save_associations: false                             # disabled by default\n      prepare_stmt: false                                       # disabled by default\n      disable_automatic_ping: false                             # disabled by default\n      disable_foreign_key_constraint_when_migrating: false      # disabled by default\n      ignore_relationships_when_migrating: false                # disabled by default\n      disable_nested_transaction: false                         # disabled by default\n      allow_global_update: false                                # disabled by default\n      query_fields: false                                       # disabled by default\n      translate_error: false                                    # disabled by default\n    log:\n      enabled: true  # to log SQL queries, disabled by default\n      level: info    # with a minimal level\n      values: true   # by adding or not clear SQL queries parameters values in logs, disabled by default\n    trace:\n      enabled: true  # to trace SQL queries, disabled by default\n      values: true   # by adding or not clear SQL queries parameters values in trace spans, disabled by default\n</code></pre> <p>See GORM Config for more details about the <code>modules.orm.config</code> configuration keys.</p> <p>For security reasons, you should avoid to hardcode DSN sensible parts (like the password) in your config files, you can use the env vars placeholders instead:</p> <pre><code># ./configs/config.yaml\nmodules:\n  orm:\n    driver: mysql\n    dsn: \"${MYSQL_USER}:${MYSQL_PASSWORD}@tcp(${MYSQL_HOST}:${MYSQL_PORT})/${MYSQL_DATABASE}?parseTime=True\"\n</code></pre>"},{"location":"modules/fxorm/#usage","title":"Usage","text":"<p>You can declare your models, for example:</p> internal/model/example.go<pre><code>package model\n\nimport (\n    \"gorm.io/gorm\"\n)\n\ntype ExampleModel struct {\n    gorm.Model\n    Name string\n}\n</code></pre> <p>This module makes available the DB in Yokai dependency injection system.</p> <p>To access it, you just need to inject it where needed, for example in a repository to manage your <code>ExampleModel</code>:</p> internal/repository/example.go<pre><code>package repository\n\nimport (\n    \"context\"\n    \"sync\"\n\n    \"github.com/foo/bar/internal/model\"\n    \"gorm.io/gorm\"\n)\n\ntype ExampleRepository struct {\n    mutex sync.Mutex\n    db    *gorm.DB\n}\n\nfunc NewExampleRepository(db *gorm.DB) *ExampleRepository {\n    return &amp;ExampleRepository{\n        db: db,\n    }\n}\n\nfunc (r *ExampleRepository) Find(ctx context.Context, id int) (*model.ExampleModel, error) {\n    r.mutex.Lock()\n    defer r.mutex.Unlock()\n\n    var exampleModel model.ExampleModel\n\n    res := r.db.WithContext(ctx).Take(&amp;exampleModel, id)\n    if res.Error != nil {\n        return nil, res.Error\n    }\n\n    return &amp;exampleModel, nil\n}\n\nfunc (r *ExampleRepository) Create(ctx context.Context, exampleModel *model.ExampleModel) error {\n    r.mutex.Lock()\n    defer r.mutex.Unlock()\n\n    res := r.db.WithContext(ctx).Create(exampleModel)\n\n    return res.Error\n}\n</code></pre> <p>Like any other services, the <code>ExampleRepository</code> needs to be registered to have its dependencies autowired:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/foo/bar/internal/repository\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleRepository\n        fx.Provide(repository.NewExampleRepository),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxorm/#migrations","title":"Migrations","text":"<p>This module provides the possibility to run your schemas migrations.</p>"},{"location":"modules/fxorm/#at-bootstrap","title":"At bootstrap","text":"<p>To run the migrations automatically at bootstrap, you just need to pass the list of models you want to auto migrate to <code>RunFxOrmAutoMigrate()</code>:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxorm\"\n    \"github.com/foo/bar/internal/model\"\n)\n\n// ...\n\nfunc Run(ctx context.Context) {\n    Bootstrapper.WithContext(ctx).RunApp(\n        // run ORM migrations for the ExampleModel model\n        fxorm.RunFxOrmAutoMigrate(&amp;model.ExampleModel{}),\n        // ...\n    )\n}\n\nfunc RunTest(tb testing.TB, options ...fx.Option) {\n    // ...\n\n    Bootstrapper.RunTestApp(\n        tb,\n        // test options\n        fx.Options(options...),\n        // run ORM migrations for the ExampleModel model for tests\n        fxorm.RunFxOrmAutoMigrate(&amp;model.ExampleModel{}),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxorm/#dedicated-command","title":"Dedicated command","text":"<p>A preferable way to run migrations is via a dedicated command.</p> <p>You can create it in the <code>cmd/</code> directory of your application:</p> cmd/migrate.go<pre><code>package cmd\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxorm\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/spf13/cobra\"\n    \"go.uber.org/fx\"\n    \"gorm.io/gorm\"\n)\n\nfunc init() {\n    rootCmd.AddCommand(migrateCmd)\n}\n\nvar migrateCmd = &amp;cobra.Command{\n    Use:   \"migrate\",\n    Short: \"Run application ORM migrations\",\n    Run: func(cmd *cobra.Command, args []string) {\n        // bootstrap, apply migrations then shutdown\n        fxcore.NewBootstrapper().\n            WithOptions(fxorm.FxOrmModule).\n            WithContext(cmd.Context()).\n            RunApp(\n                fx.Invoke(func(logger *log.Logger, db *gorm.DB, sd fx.Shutdowner) error {\n                    logger.Info().Msg(\"starting ORM auto migration\")\n\n                    // run ORM migrations for the ExampleModel model\n                    err := db.AutoMigrate(&amp;model.ExampleModel)\n                    if err != nil {\n                        logger.Error().Err(err).Msg(\"error during ORM auto migration\")\n                    } else {\n                        logger.Info().Msg(\"ORM auto migration success\")\n                    }\n\n                    // shutdown\n                    return sd.Shutdown()\n                }),\n            )\n    },\n}\n</code></pre> <p>You can then execute this command when needed by running <code>app migrate</code> from a dedicated step in your deployment pipeline.</p>"},{"location":"modules/fxorm/#performance","title":"Performance","text":"<p>See general GORM performance recommendations.</p>"},{"location":"modules/fxorm/#disable-default-transaction","title":"Disable Default Transaction","text":"<p>Gorm performs write (create/update/delete) operations by default inside a transaction to ensure data consistency, which is not optimized for performance.</p> <p>You can disable it in the configuration:</p> configs/config.yaml<pre><code>modules:\n  orm:\n    config:\n      skip_default_transaction: true # disable default transaction\n</code></pre>"},{"location":"modules/fxorm/#cache-prepared-statement","title":"Cache Prepared Statement","text":"<p>To create a prepared statement when executing any SQL (and cache them to speed up future calls):</p> configs/config.yaml<pre><code>modules:\n  orm:\n    config:\n      prepare_stmt: true # enable prepared statements\n</code></pre>"},{"location":"modules/fxorm/#health-check","title":"Health Check","text":"<p>This module provides a ready to use OrmProbe, to be used by the health check module.</p> <p>It will perform a <code>ping</code> to the configured database connection to ensure it is healthy.</p> <p>You just need to register it:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/orm/healthcheck\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the OrmProbe probe for startup, liveness and readiness checks\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewOrmProbe),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxorm/#logging","title":"Logging","text":"<p>You can enable the SQL queries automatic logging with <code>modules.orm.log.enabled=true</code>:</p> configs/config.yaml<pre><code>modules:\n  orm:\n    log:\n      enabled: true  # to log SQL queries, disabled by default\n      level: debug   # with a minimal level\n      values: true   # by adding or not clear SQL queries parameters values in logs, disabled by default\n</code></pre> <p>To get logs correlation, your need to propagate the context with <code>WithContext()</code>:</p> <pre><code>res := r.db.WithContext(ctx).Take(&amp;exampleModel, id)\n</code></pre> <p>As a result, in your application logs:</p> <pre><code>DBG latency=\"54.32\u00b5s\" sqlQuery=\"SELECT * FROM `examples` WHERE `examples`.`id` = 1 AND `examples`.`deleted_at` IS NULL LIMIT 1\" sqlRows=1\n</code></pre> <p>If needed, you can obfuscate the SQL values from your SQL queries with <code>modules.orm.log.values=false</code>, this will replace the values in your logs with <code>?</code>:</p> <pre><code>DBG latency=\"54.32\u00b5s\" sqlQuery=\"SELECT * FROM `examples` WHERE `examples`.`id` = ? AND `examples`.`deleted_at` IS NULL LIMIT 1\" sqlRows=1\n</code></pre>"},{"location":"modules/fxorm/#tracing","title":"Tracing","text":"<p>You can enable the SQL queries automatic tracing with <code>modules.orm.trace.enabled=true</code>:</p> configs/config.yaml<pre><code>modules:\n  orm:\n    trace:\n      enabled: true  # to trace SQL queries, disabled by default\n      values: true   # by adding or not clear SQL queries parameters values in trace spans, disabled by default\n</code></pre> <p>To get traces correlation, your need to propagate the context with <code>WithContext()</code>:</p> <pre><code>res := r.db.WithContext(ctx).Take(&amp;exampleModel, id)\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>db.system: \"mysql\"\ndb.statement: \"SELECT * FROM `examples` WHERE `examples`.`id` = 1 AND `examples`.`deleted_at` IS NULL LIMIT 1\"\n...\n</code></pre> <p>If needed, you can obfuscate the SQL values from your SQL queries with <code>modules.orm.trace.values=false</code>, this will replace the values in your trace spans with <code>?</code>:</p> <pre><code>db.system: \"mysql\"\ndb.statement: \"SELECT * FROM `examples` WHERE `examples`.`id` = ? AND `examples`.`deleted_at` IS NULL LIMIT 1\"\n...\n</code></pre>"},{"location":"modules/fxorm/#testing","title":"Testing","text":"<p>This module provide support for the <code>sqlite</code> databases, making your tests portable (in memory, no database required):</p> configs/config.test.yaml<pre><code>modules:\n  orm:\n    driver: sqlite   # use sqlite driver\n    dsn: \":memory:\"  # in memory\n</code></pre> <p>You can then retrieve your components using the DB, and make actual database operations:</p> internal/repository/example_test.go<pre><code>package repository_test\n\nimport (\n    \"testing\"\n\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/foo/bar/internal/repository\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.uber.org/fx\"\n    \"gorm.io/gorm\"\n)\n\nfunc TestExampleRepository(t *testing.T) {\n    var gormDB *gorm.DB\n    var exampleRepository repository.ExampleRepository\n\n    internal.RunTest(t, fx.Populate(&amp;gormDB, &amp;exampleRepository))\n\n    // prepare your test data in the sqlite database\n    exampleRepository.Create(\n        context.Background(),\n        &amp;model.ExampleModel{\n            Name: \"test\",\n        },\n    )\n\n    // some tests ...\n\n    // close DB\n    db, err := gormDB.DB()\n    assert.NoError(t, err)\n\n    err = db.Close()\n    assert.NoError(t, err)\n}\n</code></pre> <p>In <code>test</code> mode, the module won't automatically close the database connection on shutdown, to allow database manipulation after the <code>RunTest()</code> execution.</p>"},{"location":"modules/fxsql/","title":"SQL Module","text":""},{"location":"modules/fxsql/#overview","title":"Overview","text":"<p>Yokai provides a fxsql module, allowing your application to interact with databases.</p> <p>It wraps the sql module, based on database/sql.</p> <p>It comes with:</p> <ul> <li>automatic SQL operations logging and tracing</li> <li>possibility to define and execute database migrations (based on Goose)</li> <li>possibility to register and execute database seeds</li> <li>possibility to register database hooks around the SQL operations</li> </ul> <p>Since this module enables you to work with <code>sql.DB</code>, you keep full control on your database interactions with <code>SQL</code>, and you can enhance your developer experience with tools like SQLC.</p>"},{"location":"modules/fxsql/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxsql\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxsql\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // load fxsql module\n    fxsql.FxSQLModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxsql/#configuration","title":"Configuration","text":"<p>This module provides the possibility to configure the database <code>driver</code>:</p> <ul> <li><code>mysql</code> for MySQL databases (based on go-sql-driver/mysql)</li> <li><code>postgres</code> for PostgreSQL databases (based on lib/pq)</li> <li><code>sqlite</code> for SQLite databases (based on mattn/go-sqlite3)</li> </ul> configs/config.yaml<pre><code>modules:\n  sql:\n    driver: mysql                                               # database driver\n    dsn: \"user:password@tcp(localhost:3306)/db?parseTime=true\"  # database DSN\n    migrations:\n      path: db/migrations  # migrations path (empty by default)\n      stdout: true         # to print in stdout the migration execution logs (disabled by default)\n    log:\n      enabled: true        # to enable SQL queries logging (disabled by default)\n      level: debug         # to configure SQL queries logs level (debug by default)\n      arguments: true      # to add SQL queries arguments to logs (disabled by default)\n      exclude:             # to exclude SQL operations from logging (empty by default)\n        - \"connection:ping\"\n        - \"connection:reset-session\"\n    trace:\n      enabled: true        # to enable SQL queries tracing (disabled by default)\n      arguments: true      # to add SQL queries arguments to trace spans (disabled by default)\n      exclude:             # to exclude SQL operations from tracing (empty by default)\n        - \"connection:ping\"\n        - \"connection:reset-session\"\n</code></pre> <p>You can find below the list of supported <code>SQL operations</code>:</p> ConnectionStatementTransaction <ul> <li><code>connection:begin</code></li> <li><code>connection:begin-tx</code></li> <li><code>connection:exec</code></li> <li><code>connection:exec-context</code></li> <li><code>connection:query</code></li> <li><code>connection:query-context</code></li> <li><code>connection:prepare</code></li> <li><code>connection:prepare-context</code></li> <li><code>connection:ping</code></li> <li><code>connection:reset-session</code></li> <li><code>connection:close</code></li> </ul> <ul> <li><code>statement:exec</code></li> <li><code>statement:exec-context</code></li> <li><code>statement:query</code></li> <li><code>statement:query-context</code></li> </ul> <ul> <li><code>transaction:commit</code></li> <li><code>transaction:rollback</code></li> </ul>"},{"location":"modules/fxsql/#usage","title":"Usage","text":"<p>Installing this module will automatically make a configured <code>sql.DB</code> instance available in Yokai dependency injection system.</p> <p>To access it, you just need to inject it where needed, for example in a repository:</p> internal/repository/foo.go<pre><code>package repository\n\nimport (\n    \"context\"\n    \"database/sql\"\n)\n\ntype FooRepository struct {\n    db *sql.DB\n}\n\nfunc NewFooRepository(db *sql.DB) *FooRepository {\n    return &amp;FooRepository{\n        db: db,\n    }\n}\n\nfunc (r *FooRepository) Insert(ctx context.Context, bar string) (sql.Result, error) {\n    return r.db.ExecContext(ctx, \"INSERT INTO foo (bar) VALUES ?\", bar)\n}\n</code></pre> <p>Like any other services, the <code>FooRepository</code> needs to be registered to have its dependencies autowired:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/foo/bar/internal/repository\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the FooRepository\n        fx.Provide(repository.NewFooRepository),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxsql/#migrations","title":"Migrations","text":"<p>This module provides the possibility to run your <code>database migrations</code>, using Goose under the hood.</p>"},{"location":"modules/fxsql/#migrations-creation","title":"Migrations creation","text":"<p>You can configure where to find your migration files:</p> configs/config.yaml<pre><code>modules:\n  sql:\n  migrations:\n    path: db/migrations  # migrations path\n    stdout: true         # to print in stdout the migration execution logs\n</code></pre> <p>And create them following Goose SQL migrations conventions:</p> db/migrations/00001_create_foo_table.sql<pre><code>-- +goose Up\nCREATE TABLE IF NOT EXISTS foo (\n    id  INTEGER NOT NULL PRIMARY KEY,\n    bar VARCHAR(255)\n);\n\n-- +goose Down\nDROP TABLE IF EXISTS foo;\n</code></pre>"},{"location":"modules/fxsql/#migrations-execution","title":"Migrations execution","text":"<p>This is done via:</p> <ul> <li><code>RunFxSQLMigration(command, args)</code> to execute a migration command</li> <li><code>RunFxSQLMigrationAndShutdown(command, args)</code> to execute a migration command and shut down</li> </ul> <p>Available <code>migration commands</code>:</p> <ul> <li><code>up</code>: migrate the DB to the most recent version available</li> <li><code>up-by-one</code>: migrate the DB up by 1</li> <li><code>up-to VERSION</code>: migrate the DB to a specific VERSION</li> <li><code>down</code>: roll back the version by 1</li> <li><code>down-to VERSION</code>: roll back to a specific VERSION</li> <li><code>redo</code>: re-run the latest migration</li> <li><code>reset</code>: roll back all migrations</li> <li><code>status</code>: dump the migration status for the current DB</li> <li><code>version</code>: print the current version of the database</li> <li><code>create NAME [sql|go]</code>: creates new migration file with the current timestamp</li> <li><code>fix</code>: apply sequential ordering to migrations</li> <li><code>validate</code>: check migration files without running them</li> </ul>"},{"location":"modules/fxsql/#at-bootstrap","title":"At bootstrap","text":"<p>To run the migrations automatically at bootstrap, you just need to call <code>RunFxSQLMigration()</code>:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxsql\"\n)\n\n// ...\n\nfunc Run(ctx context.Context) {\n    Bootstrapper.WithContext(ctx).RunApp(\n        // run database migrations\n        fxsql.RunFxSQLMigration(\"up\"),\n        // ...\n    )\n}\n\nfunc RunTest(tb testing.TB, options ...fx.Option) {\n    // ...\n\n    Bootstrapper.RunTestApp(\n        tb,\n        // test options\n        fx.Options(options...),\n        // run database migrations for tests\n        fxsql.RunFxSQLMigration(\"up\"),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxsql/#dedicated-command","title":"Dedicated command","text":"<p>A preferable way to run migrations is via a dedicated command.</p> <p>You can create it in the <code>cmd/</code> directory of your application:</p> cmd/migrate.go<pre><code>package cmd\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxsql\"\n    \"github.com/spf13/cobra\"\n    \"go.uber.org/fx\"\n)\n\nfunc init() {\n    rootCmd.AddCommand(migrateCmd)\n}\n\nvar migrateCmd = &amp;cobra.Command{\n    Use:   \"migrate\",\n    Short: \"Run database migrations\",\n    Args:  cobra.MinimumNArgs(1),\n    Run: func(cmd *cobra.Command, args []string) {\n        fxcore.\n            NewBootstrapper().\n            WithContext(cmd.Context()).\n            WithOptions(\n                fx.NopLogger,\n                // modules\n                fxsql.FxSQLModule,\n                // migrate and shutdown\n                fxsql.RunFxSQLMigrationAndShutdown(args[0], args[1:]...),\n            ).\n            RunApp()\n    },\n}\n</code></pre> <p>You can then execute this command when needed by running for example <code>app migrate up</code> from a dedicated step in your deployment pipeline.</p>"},{"location":"modules/fxsql/#seeds","title":"Seeds","text":"<p>This module provides the possibility to <code>seed</code> your database, useful for testing.</p>"},{"location":"modules/fxsql/#seeds-creation","title":"Seeds creation","text":"<p>This module provides the Seed interface for your seeds implementations.</p> <p>For example:</p> db/seeds/example.go<pre><code>package seeds\n\nimport (\n    \"context\"\n    \"database/sql\"\n\n    \"github.com/ankorstore/yokai/config\"\n)\n\ntype ExampleSeed struct {\n    config *config.Config\n}\n\nfunc NewExampleSeed(config *config.Config) *ExampleSeed {\n    return &amp;ExampleSeed{\n        config: config,\n    }\n}\n\nfunc (s *ExampleSeed) Name() string {\n    return \"example-seed\"\n}\n\nfunc (s *ExampleSeed) Run(ctx context.Context, db *sql.DB) error {\n    _, err := db.ExecContext(\n        ctx,\n        \"INSERT INTO foo (bar) VALUES (?)\",\n        s.config.GetString(\"config.seeds.example-seed.value\"),\n    )\n\n    return err\n}\n</code></pre>"},{"location":"modules/fxsql/#seeds-registration","title":"Seeds registration","text":"<p>Once your seeds are created, you can register them via:</p> <ul> <li><code>AsSQLSeed()</code> to register a seed</li> <li><code>AsSQLSeeds()</code> to register several seeds at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/foo/bar/db/seeds\"\n    \"github.com/ankorstore/yokai/fxsql\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleSeed\n        fxsql.AsSQLSeed(seeds.NewExampleSeed),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your seeds constructors will be autowired.</p>"},{"location":"modules/fxsql/#seeds-execution","title":"Seeds execution","text":"<p>Once your seeds are registered, you can execute them via <code>RunFxSQLSeeds()</code>:</p> internal/example_test.go<pre><code>package internal_test\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/fxsql\"\n    \"github.com/foo/bar/internal\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExample(t *testing.T) {\n    internal.RunTest(\n        t,\n        // apply seeds\n        fxsql.RunFxSQLSeeds(),\n    )\n\n    // ...\n}\n</code></pre> <p>You can also call for example <code>RunFxSQLSeeds(\"example-seed\", \"other-seed\")</code> to run only specific seeds, in provided order.</p>"},{"location":"modules/fxsql/#hooks","title":"Hooks","text":"<p>This module provides the possibility to <code>extend</code> the logic around the <code>SQL operations</code> via a hooking mechanism.</p>"},{"location":"modules/fxsql/#hooks-creation","title":"Hooks creation","text":"<p>This module provides the Hook interface for your hooks implementations.</p> <p>For example:</p> db/hooks/example.go<pre><code>package hooks\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/sql\"\n)\n\ntype ExampleHook struct {\n    config *config.Config\n}\n\nfunc NewExampleHook(config *config.Config) *ExampleHook {\n    return &amp;ExampleHook{\n        config: config,\n    }\n}\n\nfunc (h *ExampleHook) Before(ctx context.Context, event *sql.HookEvent) context.Context {\n    // before SQL operation logic\n    if h.config.GetBool(\"config.hooks.example-hook.enabled\") {\n        // ...\n    }\n\n    return ctx\n}\n\nfunc (h *ExampleHook) After(ctx context.Context, event *sql.HookEvent) {\n    // after SQL operation logic\n    if h.config.GetBool(\"config.hooks.example-hook.enabled\") {\n        // ...\n    }\n}\n</code></pre>"},{"location":"modules/fxsql/#hooks-registration","title":"Hooks registration","text":"<p>Once your hooks are created, you can register them via:</p> <ul> <li><code>AsSQLHook()</code> to register a hook</li> <li><code>AsSQLHooks()</code> to register several hooks at once</li> </ul> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/foo/bar/db/hooks\"\n    \"github.com/ankorstore/yokai/fxsql\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the ExampleHook\n        fxsql.AsSQLHook(hooks.NewExampleHook),\n        // ...\n    )\n}\n</code></pre> <p>The dependencies of your hooks constructors will be autowired.</p>"},{"location":"modules/fxsql/#hooks-execution","title":"Hooks execution","text":"<p>Yokai collects all registered hooks and executes them <code>automatically</code> on each SQL operations.</p>"},{"location":"modules/fxsql/#health-check","title":"Health Check","text":"<p>This module provides a ready to use SQLProbe, to be used by the health check module.</p> <p>It will perform a <code>ping</code> to the configured database connection to ensure it is healthy.</p> <p>You just need to register it:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/sql/healthcheck\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the SQLProbe probe for startup, liveness and readiness checks\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewSQLProbe),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxsql/#logging","title":"Logging","text":"<p>You can enable the SQL queries automatic logging with <code>modules.sql.log.enabled=true</code>:</p> configs/config.yaml<pre><code>modules:\n  sql:\n    log:\n      enabled: true    # to enable SQL queries logging (disabled by default)\n      level: debug     # to configure SQL queries logs level (debug by default)\n      arguments: true  # to add SQL queries arguments to logs (disabled by default)\n      exclude:         # to exclude SQL operations from logging (empty by default)\n        - \"connection:ping\"\n        - \"connection:reset-session\"\n</code></pre> <p>As a result, in your application logs:</p> <pre><code>DBG system:\"mysql\" operation:\"connection:exec-context\" latency=\"54.32\u00b5s\" query=\"INSERT INTO foo (bar) VALUES (?)\" lastInsertId=0 rowsAffected=0\n</code></pre> <p>If needed, you can log the SQL queries arguments with <code>modules.sql.log.arguments=true</code>:</p> <pre><code>DBG system:\"mysql\" operation:\"connection:exec-context\" latency=\"54.32\u00b5s\" query=\"INSERT INTO foo (bar) VALUES (?)\" arguments=[map[Name: Ordinal:1 Value:baz]] lastInsertId=0 rowsAffected=0\n</code></pre>"},{"location":"modules/fxsql/#tracing","title":"Tracing","text":"<p>You can enable the SQL queries automatic tracing with <code>modules.sql.trace.enabled=true</code>:</p> configs/config.yaml<pre><code>modules:\n  sql:\n    trace:\n      enabled: true    # to enable SQL queries tracing (disabled by default)\n      arguments: true  # to add SQL queries arguments to trace spans (disabled by default)\n      exclude:         # to exclude SQL operations from tracing (empty by default)\n        - \"connection:ping\"\n        - \"connection:reset-session\"\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>db.system: \"mysql\"\ndb.statement: \"INSERT INTO foo (bar) VALUES (?)\"\ndb.lastInsertId: 0\ndb.rowsAffected: 0\n...\n</code></pre> <p>If needed, you can trace the SQL queries arguments with <code>modules.sql.trace.arguments=true</code>:</p> <pre><code>db.system: \"mysql\"\ndb.statement: \"INSERT INTO foo (bar) VALUES (?)\"\ndb.statement.arguments: \"[{Name: Ordinal:1 Value:baz}]\"\ndb.lastInsertId: 0\ndb.rowsAffected: 0\n...\n</code></pre>"},{"location":"modules/fxsql/#testing","title":"Testing","text":"<p>This module provide support for the <code>sqlite</code> databases, making your tests portable (in memory, no database required):</p> configs/config.test.yaml<pre><code>modules:\n  sql:\n    driver: sqlite   # use sqlite driver\n    dsn: \":memory:\"  # in memory\n</code></pre> <p>The fxgomysqlserver Yokai contrib module is also available if you want to run an embed MySQL server for your tests.</p> <p>You can then retrieve your components using the <code>sql.DB</code>, and make actual database operations:</p> internal/example_test.go<pre><code>package internal_test\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/fxsql\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/foo/bar/internal/repository\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExample(t *testing.T) {\n    var fooRepository repository.FooRepository\n\n    internal.RunTest(\n        t,\n        // apply migrations in sqlite in-memory\n        fxsql.RunFxSQLMigration(\"up\"),\n        // apply seeds in sqlite in-memory\n        fxsql.RunFxSQLSeeds(),\n        // retrieve your components\n        fx.Populate(&amp;fooRepository),\n    )\n\n    // ...\n}\n</code></pre>"},{"location":"modules/fxtrace/","title":"Trace Module","text":""},{"location":"modules/fxtrace/#overview","title":"Overview","text":"<p>Yokai provides a fxtrace module, allowing your application to produce traces.</p> <p>It wraps the trace module, based on OpenTelemetry.</p>"},{"location":"modules/fxtrace/#installation","title":"Installation","text":"<p>The fxtrace module is automatically loaded by Yokai's core.</p> <p>When you use a Yokai <code>application template</code>, you have nothing to install, it's ready to use.</p>"},{"location":"modules/fxtrace/#configuration","title":"Configuration","text":"<p>This module provides the possibility to configure a <code>processor</code>:</p> <ul> <li><code>noop</code>: to async void traces (default and fallback)</li> <li><code>stdout</code>: to async print traces to stdout</li> <li><code>otlp-grpc</code>: to async send traces to OTLP/gRPC collectors (ex: Jaeger, Grafana, etc.)</li> <li><code>test</code>: to sync store traces in memory (for testing assertions)</li> </ul> <p>If an error occurs while creating the processor (for example failing OTLP/gRPC connection), the <code>noop</code> processor will be used as safety fallback (to prevent outages).</p> <p>This module also provides possibility to configure a <code>sampler</code>:</p> <ul> <li><code>parent-based-always-on</code>: always on depending on parent (default)</li> <li><code>parent-based-always-off</code>: always off depending on parent</li> <li><code>parent-based-trace-id-ratio</code>: trace id ratio based depending on parent</li> <li><code>always-on</code>: always on</li> <li><code>always-off</code>: always off</li> <li><code>trace-id-ratio</code>: trace id ratio based</li> </ul> <p>Example with <code>stdout</code> processor (with pretty print) and <code>parent-based-trace-id-ratio</code> sampler (ratio=0.5):</p> configs/config.yaml<pre><code>modules:\n  trace:\n    processor:\n      type: stdout\n      options:\n        pretty: true\n    sampler:\n      type: parent-based-trace-id-ratio\n      options:\n        ratio: 0.5\n</code></pre> <p>Another example with <code>otlp-grpc</code> processor (sending on jaeger:4317) and <code>always-on</code> sampler:</p> configs/config.yaml<pre><code>modules:\n  trace:\n    processor:\n      type: otlp-grpc\n      options:\n        host: jaeger:4317\n    sampler:\n      type: always-on\n</code></pre>"},{"location":"modules/fxtrace/#usage","title":"Usage","text":"<p>This module makes available the TracerProvider in Yokai dependency injection system.</p> <p>It is built on top of <code>OpenTelemetry</code>, see its documentation for more details about available methods.</p> <p>You can inject the tracer provider where needed, but it's recommended to use the one carried by the <code>context.Context</code> when possible (for automatic traces correlation).</p>"},{"location":"modules/fxtrace/#testing","title":"Testing","text":"<p>This module provides the possibility to easily test your trace spans, using the TestTraceExporter with <code>modules.trace.processor.type=test</code>.</p> configs/config.test.yaml<pre><code>modules:\n  trace:\n    processor:\n      type: test # to send traces to test buffer\n</code></pre> <p>You can use the provided test assertion helpers in your tests:</p> <ul> <li><code>AssertHasTraceSpan</code>: to assert on exact name and exact attributes match</li> <li><code>AssertHasNotTraceSpan</code>: to assert on exact name and exact attributes non match</li> <li><code>AssertContainTraceSpan</code>: to assert on exact name and partial attributes match</li> <li><code>AssertContainNotTraceSpan</code>: to assert on exact name and partial attributes non match</li> </ul> <p>and use <code>Dump()</code> to print the current content of the TestTraceExporter.</p> <p>For example:</p> internal/example_test.go<pre><code>package internal_test\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/trace/tracetest\"\n    \"github.com/foo/bar/internal\"\n    \"go.opentelemetry.io/otel/attribute\"\n    \"go.opentelemetry.io/otel/trace\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestExample(t *testing.T) {\n    var traceExporter tracetest.TestTraceExporter\n\n    internal.RunTest(\n        t,\n        fx.Populate(&amp;traceExporter),\n        fx.Invoke(func(tracerProvider trace.TracerProvider) {\n            _, span := tracerProvider.Tracer(\"example tracer\").Start(\n                context.Background(),\n                \"example span\",\n                trace.WithAttributes(attribute.String(\"example name\", \"example value\")),\n            )\n            defer span.End()\n        }),\n    )\n\n    //dump spans\n    traceExporter.Dump()\n\n    // trace assertion example\n    tracetest.AssertHasTraceSpan(\n        t,\n        traceExporter,\n        \"example span\",\n        attribute.String(\"example name\", \"example value\"),\n    )\n}\n</code></pre>"},{"location":"modules/fxvalidator/","title":"Validator Module","text":""},{"location":"modules/fxvalidator/#overview","title":"Overview","text":"<p>Yokai provides a fxvalidator module, allowing you to inject a validator anywhere needed.</p> <p>It wraps the go-playground/validator module.</p>"},{"location":"modules/fxvalidator/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxvalidator\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxvalidator\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxvalidator.FXValidatorModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxvalidator/#configuration","title":"Configuration","text":"<p>Configuration reference:</p> configs/config.yaml<pre><code>modules:\n  validator:\n    tag_name: validate    # struct tag to define validation rules, default = validate\n    private_fields: false # to enable validation on private fields, disabled by default\n</code></pre>"},{"location":"modules/fxvalidator/#usage","title":"Usage","text":"<p>This module makes available a <code>*validator.Validate</code> instance in Yokai dependency injection system, that you can inject anywhere.</p> <p>For example:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"fmt\"\n\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype ExampleStruct struct {\n    Name  string `validate:\"required\"`\n    Email string `validate:\"required,email\"`\n}\n\ntype ExampleService struct {\n    validate *validator.Validate\n}\n\nfunc NewExampleService(validate *validator.Validate) *ExampleService {\n    return &amp;ExampleService{\n        validate: validate,\n    }\n}\n\nfunc (s *ExampleService) DoSomething() error {\n    es := ExampleStruct{\n        Name:  \"name\",\n        Email: \"name@example.com\",\n    }\n\n    err := s.validate.Struct(es)\n    if valErrs, ok := err.(validator.ValidationErrors); ok {\n        fmt.Println(valErrs)\n    }\n\n    return valErrs\n}\n</code></pre> <p>See go-playground/validator documentation for more details about available validation features.</p>"},{"location":"modules/fxvalidator/#customization","title":"Customization","text":"<p>This module provides the possibility to easily customize your validator.</p>"},{"location":"modules/fxvalidator/#custom-aliases","title":"Custom aliases","text":"<p>You can register custom validation aliases with <code>AsAlias()</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxvalidator\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the rla alias: provided value must be required, alpha only and lowercase\n        fxvalidator.AsAlias(\"rla\", \"required,alpha,lowercase\"),\n        // ...\n    )\n}\n</code></pre> <p>Then:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype ExampleService struct {\n    validate *validator.Validate\n}\n\nfunc NewExampleService(validate *validator.Validate) *ExampleService {\n    return &amp;ExampleService{\n        validate: validate,\n    }\n}\n\nfunc (s *ExampleService) DoSomething(ctx context.Context) error {\n    // valid\n    err := s.validate.VarCtx(ctx, \"valid\", \"rla\")\n\n    // invalid\n    err = s.validate.VarCtx(ctx, \"1234\", \"rla\")\n\n    return err\n}\n</code></pre>"},{"location":"modules/fxvalidator/#custom-validations","title":"Custom validations","text":"<p>You can register custom validations functions with <code>AsValidation()</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxvalidator\"\n    \"github.com/go-playground/validator/v10\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the foobar validation: provided lowercased value must be \"foo\" or \"bar\"\n        fxvalidator.AsValidation(\n            \"foobar\",\n            func(ctx context.Context, fl validator.FieldLevel) bool {\n                s := strings.ToLower(fl.Field().String())\n\n                return s == \"foo\" || s == \"bar\"\n            },\n            true,\n        ),\n        // ...\n    )\n}\n</code></pre> <p>Then:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype ExampleService struct {\n    validate *validator.Validate\n}\n\nfunc NewExampleService(validate *validator.Validate) *ExampleService {\n    return &amp;ExampleService{\n        validate: validate,\n    }\n}\n\nfunc (s *ExampleService) DoSomething(ctx context.Context) error {\n    // valid\n    err := s.validate.VarCtx(ctx, \"FoO\", \"foobar\")\n\n    // invalid\n    err = s.validate.VarCtx(ctx, \"invalid\", \"foobar\")\n\n    return err\n}\n</code></pre>"},{"location":"modules/fxvalidator/#custom-struct-validations","title":"Custom struct validations","text":"<p>You can register custom struct validations functions with <code>AsStructValidation()</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxvalidator\"\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/go-playground/validator/v10\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register a struct validation for the struct service.ExampleStruct{}\n        fxvalidator.AsStructValidation(\n            func(ctx context.Context, sl validator.StructLevel) {\n                fb, ok := sl.Current().Interface().(service.ExampleStruct)\n                if ok {\n                    if fb.Foo != \"foo\" {\n                        sl.ReportError(fb.Foo, \"Foo\", \"Foo\", \"invalid-foo\", \"invalid foo\")\n                    }\n                    if fb.Bar != \"bar\" {\n                        sl.ReportError(fb.Bar, \"Bar\", \"Bar\", \"invalid-bar\", \"invalid bar\")\n                    }\n                }\n            },\n            service.ExampleStruct{},\n        ),\n        // ...\n    )\n}\n</code></pre> <p>Then:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype ExampleStruct struct {\n    Foo string\n    Bar string\n}\n\ntype ExampleService struct {\n    validate *validator.Validate\n}\n\nfunc NewExampleService(validate *validator.Validate) *ExampleService {\n    return &amp;ExampleService{\n        validate: validate,\n    }\n}\n\nfunc (s *ExampleService) DoSomething(ctx context.Context) error {\n    // valid\n    err := s.validate.StructCtx(ctx, ExampleStruct{Foo: \"foo\", Bar: \"bar\"})\n\n    // invalid\n    err = s.validate.StructCtx(ctx, ExampleStruct{Foo: \"invalid\", Bar: \"\"})\n\n    return err\n}\n</code></pre>"},{"location":"modules/fxvalidator/#custom-types","title":"Custom types","text":"<p>You can register custom types functions with <code>AsCustomType()</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"reflect\"\n\n    \"github.com/ankorstore/yokai/fxvalidator\"\n    \"github.com/foo/bar/internal/service\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register a custom type function for service.Foo{} and service.Bar{}\n        fxvalidator.AsCustomType(\n            func(field reflect.Value) interface{} {\n                if f, ok := field.Interface().(service.Foo); ok {\n                    if f.Value != \"foo\" {\n                        return \"\"\n                    }\n\n                    return f.Value\n                }\n\n                if b, ok := field.Interface().(service.Bar); ok {\n                    if b.Value != \"bar\" {\n                        return \"\"\n                    }\n\n                    return b.Value\n                }\n\n                return \"\"\n            },\n            service.Foo{},\n            service.Bar{},\n        ),\n        // ...\n    )\n}\n</code></pre> <p>Then:</p> internal/service/example.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype Foo struct {\n    Value string `validate:\"required\"`\n}\n\ntype Bar struct {\n    Value string `validate:\"required\"`\n}\n\ntype ExampleStruct struct {\n    Foo Foo\n    Bar Bar\n}\n\ntype ExampleService struct {\n    validate *validator.Validate\n}\n\nfunc NewExampleService(validate *validator.Validate) *ExampleService {\n    return &amp;ExampleService{\n        validate: validate,\n    }\n}\n\nfunc (s *ExampleService) DoSomething(ctx context.Context) error {\n    // valid\n    err := s.validate.StructCtx(ctx, ExampleStruct{Foo: Foo{Value: \"foo\"}, Bar: Bar{Value: \"bar\"}})\n\n    // invalid\n    err = s.validate.StructCtx(ctx, ExampleStruct{Foo: Foo{Value: \"invalid\"}, Bar: Bar{Value: \"\"}})\n\n    return err\n}\n</code></pre>"},{"location":"modules/fxworker/","title":"Worker Module","text":""},{"location":"modules/fxworker/#overview","title":"Overview","text":"<p>Yokai provides a fxworker module, providing a workers pool to your application.</p> <p>It wraps the worker module, based on sync.</p> <p>It comes with:</p> <ul> <li>automatic panic recovery</li> <li>automatic logging</li> <li>automatic metrics</li> <li>possibility to defer workers</li> <li>possibility to limit workers max execution attempts</li> </ul>"},{"location":"modules/fxworker/#installation","title":"Installation","text":"<p>First install the module:</p> <pre><code>go get github.com/ankorstore/yokai/fxworker\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxworker\"\n)\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // load fxworker module\n    fxworker.FxWorkerModule,\n    // ...\n)\n</code></pre>"},{"location":"modules/fxworker/#configuration","title":"Configuration","text":"configs/config.yaml<pre><code>modules:\n  worker:\n    defer: 0.1             # threshold in seconds to wait before starting all workers, immediate start by default\n    attempts: 3            # max execution attempts in case of failures for all workers, no restart by default\n    metrics:\n      collect:\n        enabled: true      # to collect metrics about workers executions\n        namespace: foo     # workers metrics namespace (empty by default)\n        subsystem: bar     # workers metrics subsystem (empty by default)\n</code></pre>"},{"location":"modules/fxworker/#usage","title":"Usage","text":"<p>This module provides the possibility to register several Worker implementations, with an optional list of WorkerExecutionOption.</p> <p>They will be collected and given by Yokai to the WorkerPool in its dependency injection system.</p>"},{"location":"modules/fxworker/#workers-creation","title":"Workers creation","text":"<p>You can create your workers by implementing the Worker interface.</p> <p>For example:</p> internal/worker/example.go<pre><code>package worker\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/worker\"\n)\n\ntype ExampleWorker struct {\n    config *config.Config\n}\n\nfunc NewExampleWorker(config *config.Config) *ExampleWorker {\n    return &amp;ExampleWorker{\n        config: config,\n    }\n}\n\nfunc (w *ExampleWorker) Name() string {\n    return \"example-worker\"\n}\n\nfunc (w *ExampleWorker) Run(ctx context.Context) error {\n    logger := worker.CtxLogger(ctx)\n\n    for {\n        select {\n        case &lt;-ctx.Done():\n            logger.Info().Msg(\"stopping\")\n\n            return nil\n        default:\n            logger.Info().Msg(\"running\")\n\n            // The sleep interval can be configured in the application config files.\n            time.Sleep(time.Duration(w.config.GetFloat64(\"config.example-worker.interval\")) * time.Second)\n        }\n    }\n}\n</code></pre> <p>And the corresponding example configuration:</p> configs/config.yaml<pre><code>config:\n  example-worker:\n    interval: 3\n</code></pre>"},{"location":"modules/fxworker/#workers-registration","title":"Workers registration","text":"<p>You can register your workers with the <code>AsWorker()</code> function:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxworker\"\n    \"github.com/ankorstore/yokai/worker\"\n    w \"github.com/foo/bar/worker\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        fxworker.AsWorker(\n            w.NewExampleWorker,                   // register the ExampleWorker\n            worker.WithDeferredStartThreshold(1), // with a deferred start of 1 second\n            worker.WithMaxExecutionsAttempts(2),  // and 2 max execution attempts \n        ),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxworker/#workers-execution","title":"Workers execution","text":"<p>Yokai will automatically start the WorkerPool containing the registered workers.</p> <p>You can get, in real time, the status of your workers executions on the core dashboard:</p> <p> </p>"},{"location":"modules/fxworker/#health-check","title":"Health Check","text":"<p>This module provides a ready to use WorkerProbe, to be used by the health check module.</p> <p>It will ensure that the worker pool executions are all in healthy status.</p> <p>You just need to register it:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/worker/healthcheck\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // register the WorkerProbe probe for startup, liveness and readiness checks\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewWorkerProbe),\n        // ...\n    )\n}\n</code></pre>"},{"location":"modules/fxworker/#logging","title":"Logging","text":"<p>To get logs correlation in your workers, you need to retrieve the logger from the context with <code>log.CtxLogger()</code>:</p> <pre><code>log.CtxLogger(ctx).Info().Msg(\"example message\")\n</code></pre> <p>You can also use the shortcut function <code>worker.CtxLogger()</code>:</p> <pre><code>worker.CtxLogger(ctx)\n</code></pre> <p>As a result, log records will have the <code>worker</code> name and <code>workerExecutionID</code> fields added automatically:</p> <pre><code>INF example message module=worker service=app worker=example-worker workerExecutionID=b57be88f-163f-4a81-bf24-a389c93d804b\n</code></pre> <p>The workers logging will be based on the log module configuration.</p>"},{"location":"modules/fxworker/#tracing","title":"Tracing","text":"<p>To get traces correlation in your workers, you need to retrieve the tracer provider from the context with <code>trace.CtxTracerProvider()</code>:</p> <pre><code>ctx, span := trace.CtxTracerProvider(ctx).Tracer(\"example tracer\").Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>You can also use the shortcut function <code>worker.CtxTracer()</code>:</p> <pre><code>ctx, span := worker.CtxTracer(ctx).Start(ctx, \"example span\")\ndefer span.End()\n</code></pre> <p>As a result, in your application trace spans attributes:</p> <pre><code>service.name: app\nWorker: example-worker\nWorkerExecutionID: b57be88f-163f-4a81-bf24-a389c93d804b\n...\n</code></pre> <p>The workers tracing will be based on the trace module configuration.</p>"},{"location":"modules/fxworker/#metrics","title":"Metrics","text":"<p>You can enable workers executions automatic metrics with <code>modules.worker.metrics.collect.enable=true</code>:</p> configs/config.yaml<pre><code>modules:\n  worker:\n    metrics:\n      collect:\n        enabled: true      # to collect metrics about workers executions\n        namespace: foo     # workers metrics namespace (empty by default)\n        subsystem: bar     # workers metrics subsystem (empty by default)\n</code></pre> <p>This will collect metrics about:</p> <ul> <li>workers <code>start</code> and <code>restart</code></li> <li>workers <code>successes</code></li> <li>workers <code>failures</code></li> </ul> <p>For example, after starting Yokai's workers pool, the core HTTP server will expose in the configured metrics endpoint:</p> [GET] /metrics<pre><code># ...\n# HELP worker_executions_total Total number of workers executions\n# TYPE worker_executions_total counter\nworker_executions_total{status=\"started\",worker=\"example-worker\"} 1\n</code></pre>"},{"location":"tutorials/grpc-application/","title":"Tutorial - gRPC application","text":"<p>How to build, step by step, an gRPC application with Yokai.</p> <p> Coming soon, meanwhile you can check the gRPC demo application.</p>"},{"location":"tutorials/http-application/","title":"Tutorial - HTTP application","text":"<p>How to build, step by step, an HTTP application with Yokai.</p>"},{"location":"tutorials/http-application/#overview","title":"Overview","text":"<p>In this tutorial, we will create an <code>HTTP REST</code> API to manage gophers.</p> <p>You can find a complete implementation in the HTTP demo application.</p>"},{"location":"tutorials/http-application/#setup","title":"Setup","text":"<p>In this tutorial, we will create our application in the <code>github.com/foo/bar</code> example repository.</p>"},{"location":"tutorials/http-application/#repository-creation","title":"Repository creation","text":"<p>To create your <code>github.com/foo/bar</code> repository, you can use the HTTP application template.</p> <p>It provides:</p> <ul> <li>a ready to extend Yokai application, with the HTTP server module installed</li> <li>a ready to use dev environment, based on Air (for live reloading)</li> <li>a ready to use Dockerfile for production</li> <li>some examples of handler and test to get started</li> </ul>"},{"location":"tutorials/http-application/#repository-content","title":"Repository content","text":"<p>Once your repository is created, you should have the following the content:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>handler/</code>: HTTP handler and test examples</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> <li><code>router.go</code>: routing registration</li> </ul> </li> </ul> <p>And a <code>Makefile</code>:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"tutorials/http-application/#discovery","title":"Discovery","text":"<p>You can start your application by running:</p> <pre><code>make fresh\n</code></pre> <p>After a short time, the application will expose:</p> <ul> <li>http://localhost:8080: application example endpoint</li> <li>http://localhost:8081: application core dashboard</li> </ul>"},{"location":"tutorials/http-application/#example-endpoint","title":"Example endpoint","text":"<p>When you use the template, an example endpoint is provided on http://localhost:8080:</p> GET http://localhost:8080<pre><code>Welcome to http-app.\n</code></pre> <p>To ease development, Air is watching any changes you perform on <code>Go code</code> or <code>config files</code> to perform hot reload.</p> <p>Let's rename your application to <code>gopher-api</code> by updating <code>app.name</code> in the configuration:</p> config/config.yaml<pre><code>app:\n    name: gopher-api\n    # ...\n</code></pre> <p>Calling again http://localhost:8080 should now return:</p> GET http://localhost:8080<pre><code>Welcome to gopher-api.\n</code></pre>"},{"location":"tutorials/http-application/#core-dashboard","title":"Core dashboard","text":"<p>Yokai is providing a core dashboard on http://localhost:8081:</p> <p> </p> <p>From there, you can get:</p> <ul> <li>an overview of your application</li> <li>information and tooling about your application: build, config, metrics, pprof, etc.</li> <li>access to the configured health check endpoints</li> <li>access to the loaded modules information (when exposed)</li> </ul> <p>Here we can see for example the HTTP server information in the <code>Modules</code> section:</p> <ul> <li>server port</li> <li>active routes</li> <li>error handler</li> <li>etc</li> </ul> <p>See Yokai's core documentation for more information.</p>"},{"location":"tutorials/http-application/#implementation","title":"Implementation","text":"<p>Let's start your application implementation, by:</p> <ul> <li>adding database support</li> <li>implementing endpoints to create and list gophers</li> </ul>"},{"location":"tutorials/http-application/#database","title":"Database","text":""},{"location":"tutorials/http-application/#mysql-setup","title":"MySQL setup","text":"<p>Let's update your <code>docker-compose.yaml</code> to add a MySQL container to your stack:</p> docker-compose.yaml<pre><code>services:\n  gopher-api-app:\n    container_name: gopher-api-app\n    build:\n      dockerfile: dev.Dockerfile\n      context: .\n    networks:\n      - gopher-api\n    ports:\n      - \"8080:8080\"\n      - \"8081:8081\"\n    expose:\n      - \"8080\"\n      - \"8081\"\n    volumes:\n      - .:/app\n    env_file:\n      - .env\n\n  gopher-api-database:\n    container_name: gopher-api-database\n    image: mysql:8\n    restart: always\n    networks:\n      - gopher-api\n    volumes:\n      - gopher-api-database-data:/var/lib/mysql\n    env_file:\n      - .env\n\nvolumes:\n  gopher-api-database-data:\n    driver: local\n\nnetworks:\n  gopher-api:\n    driver: bridge\n</code></pre> <p>And the configuration in your <code>.env</code> file:</p> .env<pre><code>APP_ENV=dev\nAPP_DEBUG=true\nMYSQL_HOST=gopher-api-database\nMYSQL_PORT=3306\nMYSQL_DATABASE=gopher-api\nMYSQL_USER=user\nMYSQL_PASSWORD=password\nMYSQL_ROOT_PASSWORD=rootpassword\n</code></pre> <p>You can then refresh your stack to bring this up:</p> <pre><code>make fresh\n</code></pre>"},{"location":"tutorials/http-application/#orm-module","title":"ORM module","text":"<p>Yokai provides the ORM module, extending your application with GORM.</p> <p>You can install it:</p> <pre><code>go get github.com/ankorstore/yokai/fxorm\n</code></pre> <p>Then activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxorm\"\n)\n\n// ...\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxorm.FxOrmModule,\n    // ...\n)\n</code></pre> <p>You can then provide the module configuration:</p> configs/config.yaml<pre><code>modules:\n  orm:\n    driver: mysql\n    dsn: ${MYSQL_USER}:${MYSQL_PASSWORD}@tcp(${MYSQL_HOST}:${MYSQL_PORT})/${MYSQL_DATABASE}?parseTime=true\n    log:\n      enabled: true\n      level: info\n      values: true\n    trace:\n      enabled: true\n      values: true\n</code></pre>"},{"location":"tutorials/http-application/#model-creation","title":"Model creation","text":"<p>To manage our gophers, we need to create a model:</p> internal/model/gopher.go<pre><code>package model\n\nimport (\n    \"gorm.io/gorm\"\n)\n\ntype Gopher struct {\n    gorm.Model\n    Name string `json:\"name\" form:\"name\"`\n    Job  string `json:\"job\" form:\"job\"`\n}\n</code></pre>"},{"location":"tutorials/http-application/#model-migrations","title":"Model migrations","text":"<p>The ORM module provides ways to apply your schemas migrations.</p> <p>To run the migrations automatically at bootstrap, we just need to pass our model to <code>RunFxOrmAutoMigrate()</code>:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxorm\"\n    \"github.com/foo/bar/internal/model\"\n)\n\n// ...\n\nfunc Run(ctx context.Context) {\n    Bootstrapper.WithContext(ctx).RunApp(\n        // run ORM migrations for the Gopher model\n        fxorm.RunFxOrmAutoMigrate(&amp;model.Gopher{}),\n    )\n}\n</code></pre> <p>If you check the logs with <code>make logs</code>, you should see the migration happening:</p> <pre><code>INF starting ORM auto migration service=gopher-api\nINF ORM auto migration success service=gopher-api\n</code></pre>"},{"location":"tutorials/http-application/#health-check","title":"Health check","text":"<p>Yokai's health check module allows the core HTTP server to expose health check endpoints, useful if your application runs on Kubernetes. It will execute the registered probes.</p> <p>The ORM module provides a ready to use OrmProbe, that will <code>ping</code> the database connection to check if it's healthy.</p> <p>To register it, you can use the <code>fxhealthcheck.AsCheckerProbe()</code> function in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/orm/healthcheck\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // orm probe\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewOrmProbe),\n    )\n}\n</code></pre> <p>This will register the ORM probe for <code>startup</code>, <code>liveness</code> and <code>readiness</code> checks.</p> <p>You can check that it's properly activated on the core dashboard:</p> <p> </p>"},{"location":"tutorials/http-application/#repository","title":"Repository","text":"<p>We can create a <code>GopherRepository</code> to manage our gophers, with:</p> <ul> <li>the <code>Create()</code> function to <code>create</code> a gopher </li> <li>and the <code>FindAll()</code> function to <code>list</code> all gophers</li> </ul> internal/repository/gopher.go<pre><code>package repository\n\nimport (\n    \"context\"\n    \"sync\"\n\n    \"github.com/foo/bar/internal/model\"\n    \"gorm.io/gorm\"\n)\n\ntype GopherRepository struct {\n    mutex sync.Mutex\n    db    *gorm.DB\n}\n\nfunc NewGopherRepository(db *gorm.DB) *GopherRepository {\n    return &amp;GopherRepository{\n        db: db,\n    }\n}\n\nfunc (r *GopherRepository) Create(ctx context.Context, gopher *model.Gopher) error {\n    r.mutex.Lock()\n    defer r.mutex.Unlock()\n\n    res := r.db.WithContext(ctx).Create(gopher)\n\n    return res.Error\n}\n\nfunc (r *GopherRepository) FindAll(ctx context.Context) ([]model.Gopher, error) {\n    var gophers []model.Gopher\n\n    res := r.db.WithContext(ctx).Find(&amp;gophers)\n    if res.Error != nil {\n        return nil, res.Error\n    }\n\n    return gophers, nil\n}\n</code></pre> <p>We then need to register the repository in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/orm/healthcheck\"\n    \"github.com/foo/bar/internal/repository\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // orm probe\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewOrmProbe),\n        // services\n        fx.Provide(\n            // gophers repository\n            repository.NewGopherRepository,\n        ),\n    )\n}\n</code></pre> <p>This will automatically inject the <code>*gorm.DB</code> in the <code>GopherRepository</code> constructor.</p>"},{"location":"tutorials/http-application/#service","title":"Service","text":"<p>Now that we have a repository, let's create a <code>GopherService</code>, with:</p> <ul> <li>the <code>Create()</code> function to <code>create</code> a gopher</li> <li>and the <code>List()</code> function to <code>list</code> all gophers</li> </ul> internal/service/gopher.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/foo/bar/internal/repository\"\n)\n\ntype GopherService struct {\n    repository *repository.GopherRepository\n}\n\nfunc NewGopherService(repository *repository.GopherRepository) *GopherService {\n    return &amp;GopherService{\n        repository: repository,\n    }\n}\n\nfunc (s *GopherService) Create(ctx context.Context, gopher *model.Gopher) error {\n    return s.repository.Create(ctx, gopher)\n}\n\nfunc (s *GopherService) List(ctx context.Context) ([]model.Gopher, error) {\n    return s.repository.FindAll(ctx)\n}\n</code></pre> <p>We then need to register the service in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/orm/healthcheck\"\n    \"github.com/foo/bar/internal/repository\"\n    \"github.com/foo/bar/internal/service\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // orm probe\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewOrmProbe),\n        // services\n        fx.Provide(\n            // gophers repository\n            repository.NewGopherRepository,\n            // gophers service\n            service.NewGopherService,\n        ),\n    )\n}\n</code></pre> <p>This will automatically inject the <code>*repository.GopherRepository</code> in the <code>GopherService</code> constructor.</p> <p>In this example, this service layer is just using the repository, but in real applications, service layers are useful for example to separate business logic from data access (using the injected repository).</p> <p>Yokai's automatic dependency injection encourages to create clean code with a good separation of concerns.</p>"},{"location":"tutorials/http-application/#http-handlers","title":"HTTP handlers","text":"<p>Now that we have a <code>GopherService</code> able to create and list gophers, let's expose it via HTTP endpoints in your application.</p>"},{"location":"tutorials/http-application/#create-handler","title":"Create handler","text":"<p>Let's create a <code>CreateGopherHandler</code> to handle requests on <code>[POST] /gophers</code> to create gophers:</p> internal/handler/gopher/create.go<pre><code>package gopher\n\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype CreateGopherHandler struct {\n    service *service.GopherService\n}\n\nfunc NewCreateGopherHandler(service *service.GopherService) *CreateGopherHandler {\n    return &amp;CreateGopherHandler{\n        service: service,\n    }\n}\n\nfunc (h *CreateGopherHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        gopher := new(model.Gopher)\n        if err := c.Bind(gopher); err != nil {\n            return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"cannot bind gopher: %v\", err))\n        }\n\n        err := h.service.Create(c.Request().Context(), gopher)\n        if err != nil {\n            return fmt.Errorf(\"cannot create gopher: %w\", err)\n        }\n\n        return c.JSON(http.StatusCreated, gopher)\n    }\n}\n</code></pre> <p>We then need to register the handler for <code>[POST] /gophers</code> in <code>internal/router.go</code>:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"github.com/foo/bar/internal/handler\"\n    \"github.com/foo/bar/internal/handler/gopher\"\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options(\n        fxhttpserver.AsHandler(\"GET\", \"\", handler.NewExampleHandler),\n        // gopher creation\n        fxhttpserver.AsHandler(\"POST\", \"/gophers\", gopher.NewCreateGopherHandler),\n    )\n}\n</code></pre> <p>Let's try to call it:</p> POST http://localhost:8080/gophers<pre><code>curl -X POST http://localhost:8080/gophers -H 'Content-Type: application/json' -d '{\"name\":\"bob\",\"job\":\"builder\"}'                   \n{\n  \"ID\": 1,\n  \"CreatedAt\": \"2024-02-06T10:29:26.497Z\",\n  \"UpdatedAt\": \"2024-02-06T10:29:26.497Z\",\n  \"DeletedAt\": null,\n  \"name\": \"bob\",\n  \"job\": \"builder\"\n}\n</code></pre> <p>You should receive a response with status <code>201</code> (created), and with the created gopher representation.</p> <p>You can check the HTTP server module documentation if you need more information about registering handlers.</p>"},{"location":"tutorials/http-application/#list-handler","title":"List handler","text":"<p>Let's now create a <code>ListGopherHandler</code> to handle requests on <code>[GET] /gophers</code> to list gophers:</p> internal/handler/gopher/list.go<pre><code>package gopher\n\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype ListGophersHandler struct {\n    service *service.GopherService\n}\n\nfunc NewListGophersHandler(service *service.GopherService) *ListGophersHandler {\n    return &amp;ListGophersHandler{\n        service: service,\n    }\n}\n\nfunc (h *ListGophersHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        gophers, err := h.service.List(c.Request().Context())\n        if err != nil {\n            return fmt.Errorf(\"cannot list gophers: %w\", err)\n        }\n\n        return c.JSON(http.StatusOK, gophers)\n    }\n}\n</code></pre> <p>We then need to register the handler for <code>[GET] /gophers</code> in <code>internal/router.go</code>.</p> <p>We can group our handlers registration with <code>fxhttpserver.AsHandlersGroup()</code>:</p> internal/router.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhttpserver\"\n    \"github.com/foo/bar/internal/handler\"\n    \"github.com/foo/bar/internal/handler/gopher\"\n    \"go.uber.org/fx\"\n)\n\nfunc Router() fx.Option {\n    return fx.Options(\n        fxhttpserver.AsHandler(\"GET\", \"\", handler.NewExampleHandler),\n        // gopher handlers group\n        fxhttpserver.AsHandlersGroup(\n            \"/gophers\",\n            []*fxhttpserver.HandlerRegistration{\n                fxhttpserver.NewHandlerRegistration(\"GET\", \"\", gopher.NewListGophersHandler),\n                fxhttpserver.NewHandlerRegistration(\"POST\", \"\", gopher.NewCreateGopherHandler),\n            },\n        ),\n    )\n}\n</code></pre> <p>You can check the HTTP server module documentation if you need more information about registering handlers groups.</p> <p>Let's try to call it:</p> GET http://localhost:8080/gophers<pre><code>curl http://localhost:8080/gophers                                                                                \n[\n  {\n    \"ID\": 1,\n    \"CreatedAt\": \"2024-02-06T10:29:26.497Z\",\n    \"UpdatedAt\": \"2024-02-06T10:29:26.497Z\",\n    \"DeletedAt\": null,\n    \"name\": \"bob\",\n    \"job\": \"builder\"\n  }\n]\n</code></pre> <p>You should receive a response with status <code>200</code> (ok), and with a list of gophers containing the one previously created.</p>"},{"location":"tutorials/http-application/#observability","title":"Observability","text":"<p>At this stage, we are able to create and list gophers.</p> <p>To provide a better understanding of what is happening at runtime, let's instrument it with:</p> <ul> <li>logs</li> <li>traces</li> <li>metrics</li> </ul>"},{"location":"tutorials/http-application/#logging","title":"Logging","text":"<p>With Yokai, <code>logging</code> is <code>contextual</code>.</p> <p>This means that you should propagate the context and retrieve the logger from it in order to produce <code>correlated</code> logs.</p> <p>The HTTP server module automatically injects a logger in the context provided to HTTP handlers.</p> <p>Let's add logs to our <code>ListGophersHandler</code> with <code>log.CtxLogger()</code>:</p> internal/handler/gopher/list.go<pre><code>package gopher\n\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype ListGophersHandler struct {\n    service *service.GopherService\n}\n\nfunc NewListGophersHandler(service *service.GopherService) *ListGophersHandler {\n    return &amp;ListGophersHandler{\n        service: service,\n    }\n}\n\nfunc (h *ListGophersHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        ctx := c.Request().Context()\n\n        log.CtxLogger(ctx).Info().Msg(\"called ListGophersHandler\")\n\n        gophers, err := h.service.List(ctx)\n        if err != nil {\n            return fmt.Errorf(\"cannot list gophers: %w\", err)\n        }\n\n        return c.JSON(http.StatusOK, gophers)\n    }\n}\n</code></pre> <p>And to our <code>GopherService</code> as well:</p> internal/service/gopher.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/foo/bar/internal/repository\"\n)\n\ntype GopherService struct {\n    repository *repository.GopherRepository\n}\n\nfunc NewGopherService(repository *repository.GopherRepository) *GopherService {\n    return &amp;GopherService{\n        repository: repository,\n    }\n}\n\n// ...\n\nfunc (s *GopherService) List(ctx context.Context) ([]model.Gopher, error) {\n    log.CtxLogger(ctx).Info().Msg(\"called GopherService.List()\")\n\n    return s.repository.FindAll(ctx)\n}\n</code></pre> <p>If you call <code>[GET] http://localhost:8080/gophers</code> while observing the logs with <code>make logs</code>, you should see:</p> <pre><code>INF called GopherService.List() module=httpserver requestID=1a06ab1d-9dec-4424-a3be-23d1c929597a service=gopher-api\nINF called ListGophersHandler module=httpserver requestID=1a06ab1d-9dec-4424-a3be-23d1c929597a service=gopher-api\nDBG latency=\"446.978\u00b5s\" module=httpserver requestID=1a06ab1d-9dec-4424-a3be-23d1c929597a service=gopher-api sqlQuery=\"SELECT * FROM `gophers` WHERE `gophers`.`deleted_at` IS NULL\" sqlRows=1\nINF request logger latency=\"687.925\u00b5s\" method=GET module=httpserver referer= remoteIp=172.19.0.1 requestID=1a06ab1d-9dec-4424-a3be-23d1c929597a service=gopher-api uri=/gophers\n</code></pre> <p>You can see that:</p> <ul> <li>all logs are automatically correlated by <code>requestID</code>, allowing you to understand what happened in a specific request scope</li> <li>the ORM automatically logged the SQL query, also in this request scope</li> </ul> <p>You can get more information about ORM logging in the ORM documentation.</p>"},{"location":"tutorials/http-application/#tracing","title":"Tracing","text":"<p>With Yokai, <code>tracing</code> is <code>contextual</code>.</p> <p>This means that you should propagate the context and retrieve the tracer provider from it in order to produce <code>correlated</code> trace spans.</p> <p>The HTTP server module automatically injects the tracer provider in the context provided to HTTP handlers.</p> <p>First let's activate the trace module exporter to <code>stdout</code>:</p> configs/config.yaml<pre><code>modules:\n  trace:\n    processor:\n      type: stdout\n</code></pre> <p>Let's then add trace spans from our <code>ListGophersHandler</code> with <code>trace.CtxTracerProvider()</code>:</p> internal/handler/gopher/list.go<pre><code>package gopher\n\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n    \"github.com/foo/bar/internal/service\"\n    \"github.com/labstack/echo/v4\"\n)\n\ntype ListGophersHandler struct {\n    service *service.GopherService\n}\n\nfunc NewListGophersHandler(service *service.GopherService) *ListGophersHandler {\n    return &amp;ListGophersHandler{\n        service: service,\n    }\n}\n\nfunc (h *ListGophersHandler) Handle() echo.HandlerFunc {\n    return func(c echo.Context) error {\n        ctx := c.Request().Context()\n\n        ctx, span := trace.CtxTracerProvider(ctx).Tracer(\"gopher-api\").Start(ctx, \"ListGophersHandler span\")\n        defer span.End()\n\n        log.CtxLogger(ctx).Info().Msg(\"called ListGophersHandler\")\n\n        gophers, err := h.service.List(ctx)\n        if err != nil {\n            return fmt.Errorf(\"cannot list gophers: %w\", err)\n        }\n\n        return c.JSON(http.StatusOK, gophers)\n    }\n}\n</code></pre> <p>If you call <code>[GET] http://localhost:8080/gophers</code> while observing with <code>make logs</code>, you should see:</p> <pre><code>// logs\nINF called ListGophersHandler module=httpserver requestID=2c7f596a-e371-4640-83d7-66a3428fd024 service=gopher-api spanID=42331b45b3cfc7bc traceID=6216e1fa6691d994fd980002ede47840\nINF called GopherService.List() module=httpserver requestID=2c7f596a-e371-4640-83d7-66a3428fd024 service=gopher-api spanID=42331b45b3cfc7bc traceID=6216e1fa6691d994fd980002ede47840\nDBG latency=\"536.777\u00b5s\" module=httpserver requestID=2c7f596a-e371-4640-83d7-66a3428fd024 service=gopher-api spanID=64c20e358f00238d sqlQuery=\"SELECT * FROM `gophers` WHERE `gophers`.`deleted_at` IS NULL\" sqlRows=1 traceID=6216e1fa6691d994fd980002ede47840\nINF request logger latency=\"863.981\u00b5s\" method=GET module=httpserver referer= remoteIp=172.19.0.1 requestID=2c7f596a-e371-4640-83d7-66a3428fd024 service=gopher-api spanID=f857be99a099aa2d status=200 traceID=6216e1fa6691d994fd980002ede47840 uri=/gophers\n\n// trace spans\n{\"Name\":\"orm.Query\",\"SpanContext\":{\"TraceID\":\"6216e1fa6691d994fd980002ede47840\",\"SpanID\":\"64c20e358f00238d\",\"TraceFlags\":\"01\",\"TraceState\":\"\",\"Remote\":false},\"Parent\":{\"TraceID\":\"6216e1fa6691d994fd980002ede47840\",\"SpanID\":\"42331b45b3cfc7bc\",\"TraceFlags\":\"01\",\"TraceState\":\"\",\"Remote\":false},\"SpanKind\":3,\"StartTime\":\"2024-02-06T11:15:06.611334019Z\",\"EndTime\":\"2024-02-06T11:15:06.611341607Z\",\"Attributes\":[{\"Key\":\"guid:x-request-id\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"2c7f596a-e371-4640-83d7-66a3428fd024\"}},{\"Key\":\"db.system\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"mysql\"}},{\"Key\":\"db.statement\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"SELECT * FROM `gophers` WHERE `gophers`.`deleted_at` IS NULL\"}},{\"Key\":\"db.sql.table\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"gophers\"}}],\"Events\":null,\"Links\":null,\"Status\":{\"Code\":\"Unset\",\"Description\":\"\"},\"DroppedAttributes\":0,\"DroppedEvents\":0,\"DroppedLinks\":0,\"ChildSpanCount\":0,\"Resource\":[{\"Key\":\"service.name\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"gopher-api\"}}],\"InstrumentationLibrary\":{\"Name\":\"orm\",\"Version\":\"\",\"SchemaURL\":\"\"}}\n{\"Name\":\"ListGophersHandler span\",\"SpanContext\":{\"TraceID\":\"6216e1fa6691d994fd980002ede47840\",\"SpanID\":\"42331b45b3cfc7bc\",\"TraceFlags\":\"01\",\"TraceState\":\"\",\"Remote\":false},\"Parent\":{\"TraceID\":\"6216e1fa6691d994fd980002ede47840\",\"SpanID\":\"f857be99a099aa2d\",\"TraceFlags\":\"01\",\"TraceState\":\"\",\"Remote\":false},\"SpanKind\":1,\"StartTime\":\"2024-02-06T11:15:06.610681301Z\",\"EndTime\":\"2024-02-06T11:15:06.611506266Z\",\"Attributes\":[{\"Key\":\"guid:x-request-id\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"2c7f596a-e371-4640-83d7-66a3428fd024\"}}],\"Events\":null,\"Links\":null,\"Status\":{\"Code\":\"Unset\",\"Description\":\"\"},\"DroppedAttributes\":0,\"DroppedEvents\":0,\"DroppedLinks\":0,\"ChildSpanCount\":1,\"Resource\":[{\"Key\":\"service.name\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"gopher-api\"}}],\"InstrumentationLibrary\":{\"Name\":\"gopher-api\",\"Version\":\"\",\"SchemaURL\":\"\"}}\n{\"Name\":\"GET /gophers\",\"SpanContext\":{\"TraceID\":\"6216e1fa6691d994fd980002ede47840\",\"SpanID\":\"f857be99a099aa2d\",\"TraceFlags\":\"01\",\"TraceState\":\"\",\"Remote\":false},\"Parent\":{\"TraceID\":\"00000000000000000000000000000000\",\"SpanID\":\"0000000000000000\",\"TraceFlags\":\"00\",\"TraceState\":\"\",\"Remote\":false},\"SpanKind\":2,\"StartTime\":\"2024-02-06T11:15:06.610638183Z\",\"EndTime\":\"2024-02-06T11:15:06.611598344Z\",\"Attributes\":[{\"Key\":\"http.route\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"/gophers\"}},{\"Key\":\"http.method\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"GET\"}},{\"Key\":\"http.scheme\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"http\"}},{\"Key\":\"http.flavor\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"1.1\"}},{\"Key\":\"net.host.name\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"gopher-api\"}},{\"Key\":\"net.host.port\",\"Value\":{\"Type\":\"INT64\",\"Value\":8080}},{\"Key\":\"net.sock.peer.addr\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"172.19.0.1\"}},{\"Key\":\"net.sock.peer.port\",\"Value\":{\"Type\":\"INT64\",\"Value\":38054}},{\"Key\":\"http.user_agent\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36\"}},{\"Key\":\"guid:x-request-id\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"2c7f596a-e371-4640-83d7-66a3428fd024\"}},{\"Key\":\"http.status_code\",\"Value\":{\"Type\":\"INT64\",\"Value\":200}}],\"Events\":null,\"Links\":null,\"Status\":{\"Code\":\"Unset\",\"Description\":\"\"},\"DroppedAttributes\":0,\"DroppedEvents\":0,\"DroppedLinks\":0,\"ChildSpanCount\":1,\"Resource\":[{\"Key\":\"service.name\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"gopher-api\"}}],\"InstrumentationLibrary\":{\"Name\":\"gopher-api\",\"Version\":\"\",\"SchemaURL\":\"\"}}\n</code></pre> <p>Here, we can see on logs side, that:</p> <ul> <li>they are still correlated by <code>requestID</code></li> <li>but they also have the <code>traceID</code> and <code>spanID</code> fields, correlating logs and trace spans</li> </ul> <p>And on trace spans side, that:</p> <ul> <li>they are correlated by <code>TraceID</code></li> <li>they contain the <code>guid:x-request-id</code> attribute matching the logs <code>requestID</code></li> <li>the ORM automatically traced the SQL query</li> </ul> <p>You can get more information about ORM tracing in the ORM documentation.</p>"},{"location":"tutorials/http-application/#metrics","title":"Metrics","text":"<p>Yokai's metrics module is collecting and exposing automatically metrics.</p> <p>The core HTTP server of your application will expose them by default on http://localhost:8081/metrics, but you can also see them on your core dashboard:</p> <p> </p> <p>You can see that, by default, the HTTP server module automatically collects HTTP requests metrics on your HTTP handlers.</p> <p>Let's now add an example custom metric in our <code>GopherService</code> to count the number of times we listed the gophers:</p> internal/service/gopher.go<pre><code>package service\n\nimport (\n    \"context\"\n\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/foo/bar/internal/repository\"\n    \"github.com/prometheus/client_golang/prometheus\"\n)\n\nvar GopherListCounter = prometheus.NewCounter(prometheus.CounterOpts{\n    Name: \"gophers_list_total\",\n    Help: \"The number of times gophers were listed\",\n})\n\ntype GopherService struct {\n    repository *repository.GopherRepository\n}\n\nfunc NewGopherService(repository *repository.GopherRepository) *GopherService {\n    return &amp;GopherService{\n        repository: repository,\n    }\n}\n\nfunc (s *GopherService) Create(ctx context.Context, gopher *model.Gopher) error {\n    return s.repository.Create(ctx, gopher)\n}\n\nfunc (s *GopherService) List(ctx context.Context) ([]model.Gopher, error) {\n    log.CtxLogger(ctx).Info().Msg(\"called GopherService.List()\")\n\n    GopherListCounter.Inc()\n\n    return s.repository.FindAll(ctx)\n}\n</code></pre> <p>To collect this metric, we need to register it with <code>fxmetrics.AsMetricsCollector()</code> in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"github.com/ankorstore/yokai/fxmetrics\"\n    \"github.com/ankorstore/yokai/orm/healthcheck\"\n    \"github.com/foo/bar/internal/repository\"\n    \"github.com/foo/bar/internal/service\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // orm probe\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewOrmProbe),\n        // services\n        fx.Provide(\n            // gophers repository\n            repository.NewGopherRepository,\n            // gophers service\n            service.NewGopherService,\n        ),\n        // gophers list metric\n        fxmetrics.AsMetricsCollector(service.GopherListCounter),\n    )\n}\n</code></pre> <p>If you call <code>[GET] http://localhost:8080/gophers</code>, you can then check the metrics on the core metrics endpoint:</p> [GET] http://localhost:8081/metrics<pre><code># ...\n# HELP gophers_list_total The number of times gophers were listed\n# TYPE gophers_list_total counter\ngophers_list_total 1\n</code></pre>"},{"location":"tutorials/http-application/#testing","title":"Testing","text":"<p>At this stage, we are able to create and list gophers, and we have observability signals to monitor this.</p> <p>The next step is to provide tests for your application, to ensure it's behaving as expected.</p>"},{"location":"tutorials/http-application/#configuration","title":"Configuration","text":"<p>Yokai's bootstrapper provides a <code>RunTest()</code> function to start your application in <code>test</code> mode.</p> <p>This will automatically set the env var <code>APP_ENV=test</code>, and will load your test configuration.</p> <p>For our tests, we can configure:</p> <ul> <li>the log module to send logs to a <code>test buffer</code></li> <li>the trace module to send trace spans to a <code>test exporter</code></li> <li>the ORM module to use an SQLite database, in memory, to make our tests easily portable on any CI pipeline (no need to spin up a MySQL instance)</li> </ul> <p>Let's set the testing configuration in <code>config/config.test.yaml</code> and activate the <code>debug</code>:</p> config/config.test.yaml<pre><code>app:\n  debug: true\nmodules:\n  log:\n    level: debug\n    output: test\n  trace:\n    processor:\n      type: test\n  orm:\n    driver: sqlite\n    dsn: \":memory:\"\n</code></pre> <p>We also need to update the in bootstrapper the <code>RunTest()</code> function to apply your model migrations via <code>RunFxOrmAutoMigrate()</code>:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai/fxorm\"\n    \"github.com/foo/bar/internal/model\"\n    \"go.uber.org/fx\"\n)\n\n// ...\n\nfunc RunTest(tb testing.TB, options ...fx.Option) {\n    // ...\n\n    Bootstrapper.RunTestApp(\n        tb,\n        fx.Options(options...),\n        fxorm.RunFxOrmAutoMigrate(&amp;model.Gopher{}),\n    )\n}\n</code></pre> <p>This will enable your tests to use the SQLite database automatically with the schema matching your model.</p>"},{"location":"tutorials/http-application/#implementation_1","title":"Implementation","text":"<p>We can now provide <code>functional</code> tests for your application endpoints.</p> <p>Let's create our <code>TestListGophersHandlerSuccess</code> test in the <code>gopher_test</code> package:</p> internal/handler/gopher/list_test.go<pre><code>package gopher_test\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"strings\"\n    \"testing\"\n\n    \"github.com/ankorstore/yokai/log/logtest\"\n    \"github.com/ankorstore/yokai/trace/tracetest\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/foo/bar/internal/model\"\n    \"github.com/foo/bar/internal/repository\"\n    \"github.com/labstack/echo/v4\"\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/testutil\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestListGophersHandlerSuccess(t *testing.T) {\n    // extraction\n    var httpServer *echo.Echo\n    var logBuffer logtest.TestLogBuffer\n    var traceExporter tracetest.TestTraceExporter\n    var metricsRegistry *prometheus.Registry\n    var repo *repository.GopherRepository\n\n    // run test\n    internal.RunTest(\n        t,\n        fx.Populate(&amp;httpServer, &amp;logBuffer, &amp;traceExporter, &amp;metricsRegistry, &amp;repo),\n    )\n\n    // populate database\n    err := repo.Create(context.Background(), &amp;model.Gopher{\n        Name: \"bob\",\n        Job:  \"builder\",\n    })\n    assert.NoError(t, err)\n\n    err = repo.Create(context.Background(), &amp;model.Gopher{\n        Name: \"alice\",\n        Job:  \"doctor\",\n    })\n    assert.NoError(t, err)\n\n    // [GET] /gophers response assertion\n    req := httptest.NewRequest(http.MethodGet, \"/gophers\", nil)\n    rec := httptest.NewRecorder()\n    httpServer.ServeHTTP(rec, req)\n\n    assert.Equal(t, http.StatusOK, rec.Code)\n\n    var gophers []*model.Gopher\n    err = json.Unmarshal(rec.Body.Bytes(), &amp;gophers)\n    assert.NoError(t, err)\n\n    assert.Len(t, gophers, 2)\n    assert.Equal(t, gophers[0].Name, \"bob\")\n    assert.Equal(t, gophers[0].Job, \"builder\")\n    assert.Equal(t, gophers[1].Name, \"alice\")\n    assert.Equal(t, gophers[1].Job, \"doctor\")\n\n    // logs assertion\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":   \"info\",\n        \"message\": \"called ListGophersHandler\",\n    })\n\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":   \"info\",\n        \"message\": \"called GopherService.List()\",\n    })\n\n    // trace assertion\n    tracetest.AssertHasTraceSpan(t, traceExporter, \"ListGophersHandler span\")\n\n    // metrics assertion\n    expectedMetric := `\n        # HELP gophers_list_total The number of times gophers were listed\n        # TYPE gophers_list_total counter\n        gophers_list_total 1\n    `\n\n    err = testutil.GatherAndCompare(\n        metricsRegistry,\n        strings.NewReader(expectedMetric),\n        \"gophers_list_total\",\n    )\n    assert.NoError(t, err)\n}\n</code></pre> <p>In this functional test:</p> <ul> <li>we start the application in test mode</li> <li>we populate the test database with fixtures</li> <li>we send an HTTP request</li> <li>we assert on the HTTP response status and body</li> <li>we assert on the observability signals (logs, traces and metrics)</li> </ul> <p>You can then run <code>make test</code>:</p> <pre><code>=== RUN   TestListGophersHandlerSuccess\n--- PASS: TestListGophersHandlerSuccess (0.00s)\nPASS\n</code></pre> <p>This tutorial will only cover testing of the <code>ListGopherHandler</code> as example, you need to provide other <code>functional</code> tests and the classic <code>unit</code> and <code>integration</code> tests for the rest of your application.</p> <p>Thanks to Yokai's dependency injection system and testing tools, it's easy to provide mocks as dependencies for your implementations.</p>"},{"location":"tutorials/mcp-application/","title":"Tutorial - MCP application","text":"<p>How to build, step by step, an MCP server application with Yokai.</p> <p> Coming soon, meanwhile you can check the MCP demo application.</p>"},{"location":"tutorials/worker-application/","title":"Tutorial - worker application","text":"<p>How to build, step by step, a worker application with Yokai.</p>"},{"location":"tutorials/worker-application/#overview","title":"Overview","text":"<p>In this tutorial, we will create a <code>worker</code> application subscribing to Pub/Sub.</p> <p>You can find a complete implementation in the worker demo application.</p>"},{"location":"tutorials/worker-application/#application-setup","title":"Application setup","text":"<p>In this tutorial, we will create our application in the <code>github.com/foo/bar</code> example repository.</p>"},{"location":"tutorials/worker-application/#repository-creation","title":"Repository creation","text":"<p>To create your <code>github.com/foo/bar</code> repository, you can use the worker application template.</p> <p>It provides:</p> <ul> <li>a ready to extend Yokai application, with the worker module installed</li> <li>a ready to use dev environment, based on Air (for live reloading)</li> <li>a ready to use Dockerfile for production</li> <li>some examples of worker and test to get started</li> </ul>"},{"location":"tutorials/worker-application/#repository-content","title":"Repository content","text":"<p>Once your repository is created, you should have the following the content:</p> <ul> <li><code>cmd/</code>: entry points</li> <li><code>configs/</code>: configuration files</li> <li><code>internal/</code>:<ul> <li><code>worker/</code>: worker and test examples</li> <li><code>bootstrap.go</code>: bootstrap</li> <li><code>register.go</code>: dependencies registration</li> </ul> </li> </ul> <p>And a <code>Makefile</code>:</p> <pre><code>make up     # start the docker compose stack\nmake down   # stop the docker compose stack\nmake logs   # stream the docker compose stack logs\nmake fresh  # refresh the docker compose stack\nmake test   # run tests\nmake lint   # run linter\n</code></pre>"},{"location":"tutorials/worker-application/#discovery","title":"Discovery","text":"<p>You can start your application by running:</p> <pre><code>make fresh\n</code></pre> <p>After a short time, the application will expose the application core dashboard on http://localhost:8081.</p>"},{"location":"tutorials/worker-application/#example-worker","title":"Example worker","text":"<p>When you use the template, an example worker is provided.</p> <p>It logs periodically the message <code>running</code>, and the interval can be configured in <code>configs/config.yaml</code>:</p> configs/config.yaml<pre><code>config:\n  example-worker:\n    interval: 3\n</code></pre> <p>You can run <code>make logs</code> to see it in action:</p> <pre><code>INF running module=worker service=worker-app worker=example-worker workerExecutionID=346775a2-6be5-43c3-907f-100a986cb2dc\n</code></pre> <p>To ease development, Air is watching any changes you perform on <code>Go code</code> or <code>config files</code> to perform hot reload.</p> <p>Let's change:</p> <ul> <li>the application name to <code>pubsub-worker</code> in <code>app.name</code></li> <li>the worker interval to <code>1</code> in <code>config.example-worker.interval</code></li> </ul> config/config.yaml<pre><code>app:\n  name: pubsub-worker\nconfig:\n  example-worker:\n    interval: 1\n</code></pre> <p>You can observe the logs again with <code>make logs</code> to see the changes hot reloaded.</p>"},{"location":"tutorials/worker-application/#core-dashboard","title":"Core dashboard","text":"<p>Yokai is providing a core dashboard on http://localhost:8081:</p> <p> </p> <p>From there, you can get:</p> <ul> <li>an overview of your application</li> <li>information and tooling about your application: build, config, metrics, pprof, etc.</li> <li>access to the configured health check endpoints</li> <li>access to the loaded modules information (when exposed)</li> </ul> <p>Here we can see for example the worker information in the <code>Modules</code> section:</p> <ul> <li>active workers</li> <li>their events</li> <li>and their status</li> </ul> <p>See Yokai's core documentation for more information.</p>"},{"location":"tutorials/worker-application/#implementation","title":"Implementation","text":"<p>Let's start your application implementation, by:</p> <ul> <li>adding Pub/Sub support</li> <li>implementing a worker to subscribe to Pub/Sub</li> </ul>"},{"location":"tutorials/worker-application/#pubsub","title":"Pub/Sub","text":""},{"location":"tutorials/worker-application/#pubsub-setup","title":"Pub/Sub setup","text":"<p>Let's update your <code>docker-compose.yaml</code> to add to your stack:</p> <ul> <li>a Pub/Sub emulator container</li> <li>a Pub/Sub UI container, working with the emulator</li> </ul> docker-compose.yaml<pre><code>services:\n  pubsub-worker:\n    build:\n      dockerfile: dev.Dockerfile\n      context: .\n    networks:\n      - pubsub-worker-network\n    ports:\n      - \"8081:8081\"\n    expose:\n      - \"8081\"\n    volumes:\n      - .:/app\n    env_file:\n      - .env\n\n  pubsub-worker-pubsub:\n    container_name: pubsub-worker-pubsub\n    image: messagebird/gcloud-pubsub-emulator:latest\n    networks:\n      - pubsub-worker-network\n    ports:\n      - \"8681:8681\"\n    env_file:\n      - .env\n    environment:\n      - PUBSUB_PROJECT1=${PUBSUB_PROJECT_ID:-demo-project},${PUBSUB_TOPIC_ID:-demo-topic}:${PUBSUB_SUBSCRIPTION_ID:-demo-subscription}\n\n  pubsub-worker-pubsub-ui:\n    container_name: pubsub-worker-pubsub-ui\n    image: echocode/gcp-pubsub-emulator-ui:latest\n    networks:\n      - pubsub-worker-network\n    ports:\n      - \"8680:8680\"\n    expose:\n      - \"8680\"\n    env_file:\n      - .env\n    environment:\n      - PUBSUB_EMULATOR_HOST=${PUBSUB_EMULATOR_HOST:-pubsub-worker-pubsub:8681}\n      - GCP_PROJECT_IDS=${PUBSUB_PROJECT_ID:-demo-project}\n\nnetworks:\n  pubsub-worker-network:\n    driver: bridge\n</code></pre> <p>And the configuration in your <code>.env</code> file:</p> .env<pre><code>APP_ENV=dev\nAPP_DEBUG=true\nPUBSUB_PROJECT_ID=demo-project\nPUBSUB_TOPIC_ID=demo-topic\nPUBSUB_SUBSCRIPTION_ID=demo-subscription\nPUBSUB_EMULATOR_HOST=pubsub-worker-pubsub:8681\n</code></pre> <p>You can then refresh your stack to bring this up:</p> <pre><code>make fresh\n</code></pre> <p>This will start the Pub/Sub emulator, with:</p> <ul> <li>the <code>demo-project</code> project ID</li> <li>auto creation of the <code>demo-topic</code> topic</li> <li>auto creation of the <code>demo-subscription</code> subscription</li> </ul> <p>You can check that everything is set up by accessing the Pub/Sub UI on http://localhost:8680:</p> <p></p>"},{"location":"tutorials/worker-application/#pubsub-module","title":"Pub/Sub module","text":"<p>Yokai's contrib modules repository provides a fxgcppubsub module, offering a <code>*pubsub.Client</code>.</p> <p>You just need to install it:</p> <pre><code>go get github.com/ankorstore/yokai-contrib/fxgcppubsub\n</code></pre> <p>And activate it in your application bootstrapper:</p> internal/bootstrap.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxcore\"\n    \"github.com/ankorstore/yokai-contrib/fxgcppubsub\"\n)\n\n// ...\n\nvar Bootstrapper = fxcore.NewBootstrapper().WithOptions(\n    // modules registration\n    fxgcppubsub.FxGcpPubSubModule,\n    // ...\n)\n</code></pre> <p>You can then provide the module configuration:</p> configs/config.yaml<pre><code>modules:\n  gcppubsub:\n    project:\n      id: demo-project\n    healthcheck:\n      subscriptions:\n        - demo-subscription\nconfig:\n  topic:\n    id: demo-topic\n  subscription:\n    id: demo-subscription\n</code></pre> <p>You can check the fxgcppubsub module documentation to get more details about the available configuration.</p>"},{"location":"tutorials/worker-application/#health-check","title":"Health check","text":"<p>Yokai's health check module allows the core HTTP server to expose health check endpoints, useful if your application runs on Kubernetes. It will execute the registered probes.</p> <p>The fxgcppubsub module provides a ready to use GcpPubSubSubscriptionsProbe, that will <code>check</code> if a configured <code>subscription</code> is reachable.</p> <p>To register it, you can use the <code>fxhealthcheck.AsCheckerProbe()</code> function in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai-contrib/fxgcppubsub/healthcheck\"\n    \"github.com/ankorstore/yokai/fxhealthcheck\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // Pub/Sub subscription probe\n        fxhealthcheck.AsCheckerProbe(healthcheck.NewGcpPubSubSubscriptionsProbe),\n        // ...\n    )\n}\n</code></pre> <p>This will register the ORM probe for <code>startup</code>, <code>liveness</code> and <code>readiness</code> checks.</p> <p>You can check that it's properly activated on the core dashboard:</p> <p> </p>"},{"location":"tutorials/worker-application/#worker","title":"Worker","text":"<p>We can create a <code>SubscribeWorker</code> to subscribe to the <code>demo-subscription</code> subscription:</p> internal/worker/subscribe.go<pre><code>package worker\n\nimport (\n    \"context\"\n\n    \"cloud.google.com/go/pubsub\"\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n)\n\ntype SubscribeWorker struct {\n    config *config.Config\n    client *pubsub.Client\n}\n\nfunc NewSubscribeWorker(config *config.Config, client *pubsub.Client) *SubscribeWorker {\n    return &amp;SubscribeWorker{\n        config: config,\n        client: client,\n    }\n}\n\nfunc (w *SubscribeWorker) Name() string {\n    return \"subscribe-worker\"\n}\n\nfunc (w *SubscribeWorker) Run(ctx context.Context) error {\n    subscription := w.client.Subscription(w.config.GetString(\"config.subscription.id\"))\n\n    return subscription.Receive(ctx, func(c context.Context, msg *pubsub.Message) {\n        log.CtxLogger(c).Info().Msgf(\n            \"received message: id=%v, data=%v\",\n            msg.ID,\n            string(msg.Data),\n        )\n\n        msg.Ack()\n    })\n}\n</code></pre> <p>We then need to register the worker in <code>internal/register.go</code> with <code>fxworker.AsWorker()</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxworker\"\n    \"github.com/foo/bar/internal/worker\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // Pub/Sub worker\n        fxworker.AsWorker(worker.NewSubscribeWorker),\n        // ...\n    )\n}\n</code></pre> <p>This will:</p> <ul> <li>automatically inject the <code>*config.Config</code> and the <code>*pubsub.Client</code> in the <code>SubscribeWorker</code> constructor</li> <li>and make the <code>SubscribeWorker</code> registered in the worker module's workers pool</li> </ul>"},{"location":"tutorials/worker-application/#publication","title":"Publication","text":"<p>Let's first refresh your stack by running <code>make fresh</code>.</p> <p>You can check in your application core dashboard that the worker is properly running:</p> <p> </p> <p>You can open your browser on http://localhost:8680/project/demo-project/topic/demo-topic:</p> <p></p> <p>And use the Pub/Sub UI to publish a <code>test message</code>.</p> <p>You can check your application logs with <code>make logs</code>, and you should see the worker in action:</p> <pre><code>INF received message: id=1, data=test message module=worker service=pubsub-worker worker=subscribe-worker\n</code></pre>"},{"location":"tutorials/worker-application/#observability","title":"Observability","text":"<p>At this stage, your application is able to subscribe to Pub/Sub.</p> <p>To provide a better understanding of what is happening at runtime, let's instrument it with:</p> <ul> <li>logs</li> <li>traces</li> <li>metrics</li> </ul>"},{"location":"tutorials/worker-application/#logging","title":"Logging","text":"<p>With Yokai, <code>logging</code> is <code>contextual</code>.</p> <p>This means that you should propagate the context and retrieve the logger from it in order to produce <code>correlated</code> logs.</p> <p>The worker module automatically injects a logger in the context provided to workers.</p> <p>Let's add more logs to our <code>SubscribeWorker</code> with <code>log.CtxLogger()</code>:</p> internal/worker/subscribe.go<pre><code>package worker\n\nimport (\n    \"context\"\n\n    \"cloud.google.com/go/pubsub\"\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n)\n\ntype SubscribeWorker struct {\n    config *config.Config\n    client *pubsub.Client\n}\n\nfunc NewSubscribeWorker(config *config.Config, client *pubsub.Client) *SubscribeWorker {\n    return &amp;SubscribeWorker{\n        config: config,\n        client: client,\n    }\n}\n\nfunc (w *SubscribeWorker) Name() string {\n    return \"subscribe-worker\"\n}\n\nfunc (w *SubscribeWorker) Run(ctx context.Context) error {\n    subscription := w.client.Subscription(w.config.GetString(\"config.subscription.id\"))\n\n    return subscription.Receive(ctx, func(c context.Context, msg *pubsub.Message) {\n        logger := log.CtxLogger(c)\n\n        logger.Info().Msgf(\"in %s\", w.Name())\n\n        logger.Info().Msgf(\n            \"received message: id=%v, data=%v\",\n            msg.ID,\n            string(msg.Data),\n        )\n\n        msg.Ack()\n    })\n}\n</code></pre> <p>If you publish another message while observing the logs with <code>make logs</code>, you should see:</p> <pre><code>INF in subscribe-worker module=worker service=pubsub-worker worker=subscribe-worker workerExecutionID=fd2fd994-bc7a-4715-9d12-0b8075acb74a\nINF received message: id=2, data=test message module=worker service=pubsub-worker worker=subscribe-worker workerExecutionID=fd2fd994-bc7a-4715-9d12-0b8075acb74a\n</code></pre> <p>You can see that:</p> <ul> <li>logs are automatically extended with the <code>worker</code> field, to know which worker produced them</li> <li>logs are automatically correlated by <code>workerExecutionID</code>, allowing you to understand what happened in a specific worker execution</li> </ul> <p>You can get more information about workers logging in the worker documentation.</p>"},{"location":"tutorials/worker-application/#tracing","title":"Tracing","text":"<p>With Yokai, <code>tracing</code> is <code>contextual</code>.</p> <p>This means that you should propagate the context and retrieve the tracer provider from it in order to produce <code>correlated</code> trace spans.</p> <p>The worker module automatically injects the tracer provider in the context provided to workers.</p> <p>First let's activate the trace module exporter to <code>stdout</code>:</p> configs/config.yaml<pre><code>modules:\n  trace:\n    processor: \n      type: stdout\n</code></pre> <p>Let's then add trace spans to our <code>SubscribeWorker</code> with <code>trace.CtxTracerProvider()</code>:</p> internal/worker/subscribe.go<pre><code>package worker\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"cloud.google.com/go/pubsub\"\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n)\n\ntype SubscribeWorker struct {\n    config *config.Config\n    client *pubsub.Client\n}\n\nfunc NewSubscribeWorker(config *config.Config, client *pubsub.Client) *SubscribeWorker {\n    return &amp;SubscribeWorker{\n        config: config,\n        client: client,\n    }\n}\n\nfunc (w *SubscribeWorker) Name() string {\n    return \"subscribe-worker\"\n}\n\nfunc (w *SubscribeWorker) Run(ctx context.Context) error {\n    subscription := w.client.Subscription(w.config.GetString(\"config.subscription.id\"))\n\n    return subscription.Receive(ctx, func(c context.Context, msg *pubsub.Message) {\n        c, span := trace.CtxTracerProvider(c).Tracer(w.Name()).Start(c, fmt.Sprintf(\"%s span\", w.Name()))\n        defer span.End()\n\n        logger := log.CtxLogger(c)\n\n        logger.Info().Msgf(\"in %s\", w.Name())\n\n        logger.Info().Msgf(\n            \"received message: id=%v, data=%v\",\n            msg.ID,\n            string(msg.Data),\n        )\n\n        msg.Ack()\n    })\n}\n</code></pre> <p>If you publish another message while observing the logs with <code>make logs</code>, you should see:</p> <pre><code>// logs\nINF received message: id=3, data=test message module=worker service=pubsub-worker spanID=0fa9c8043ea50abe traceID=6be5177482b1386fefe40ef756ee61fa worker=subscribe-worker workerExecutionID=9be1a627-ecc5-4626-b0a5-891ab86b4de7\nINF in subscribe-worker module=worker service=pubsub-worker spanID=0fa9c8043ea50abe traceID=6be5177482b1386fefe40ef756ee61fa worker=subscribe-worker workerExecutionID=9be1a627-ecc5-4626-b0a5-891ab86b4de7\n\n// trace span\n{\"Name\":\"subscribe-worker span\",\"SpanContext\":{\"TraceID\":\"6be5177482b1386fefe40ef756ee61fa\",\"SpanID\":\"0fa9c8043ea50abe\",\"TraceFlags\":\"01\",\"TraceState\":\"\",\"Remote\":false},\"Parent\":{\"TraceID\":\"00000000000000000000000000000000\",\"SpanID\":\"0000000000000000\",\"TraceFlags\":\"00\",\"TraceState\":\"\",\"Remote\":false},\"SpanKind\":1,\"StartTime\":\"2024-02-08T10:46:14.807695672Z\",\"EndTime\":\"2024-02-08T10:46:14.807857105Z\",\"Attributes\":[{\"Key\":\"Worker\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"subscribe-worker\"}},{\"Key\":\"WorkerExecutionID\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"9be1a627-ecc5-4626-b0a5-891ab86b4de7\"}}],\"Events\":null,\"Links\":null,\"Status\":{\"Code\":\"Unset\",\"Description\":\"\"},\"DroppedAttributes\":0,\"DroppedEvents\":0,\"DroppedLinks\":0,\"ChildSpanCount\":0,\"Resource\":[{\"Key\":\"service.name\",\"Value\":{\"Type\":\"STRING\",\"Value\":\"pubsub-worker\"}}],\"InstrumentationLibrary\":{\"Name\":\"subscribe-worker\",\"Version\":\"\",\"SchemaURL\":\"\"}}\n</code></pre> <p>Here, we can see on logs side, that:</p> <ul> <li>they are still correlated by <code>workerExecutionID</code></li> <li>but they also have the <code>traceID</code> and <code>spanID</code> fields, correlating logs and trace spans</li> </ul> <p>And on trace span side, that:</p> <ul> <li>it is correlated by <code>TraceID</code></li> <li>it contains the <code>Worker</code> attribute matching the worker name </li> <li>it contains the <code>WorkerExecutionID</code> attribute matching the logs <code>workerExecutionID</code></li> </ul> <p>You can get more information about workers tracing in the worker documentation.</p>"},{"location":"tutorials/worker-application/#metrics","title":"Metrics","text":"<p>Yokai's metrics module is collecting and exposing automatically metrics.</p> <p>The core HTTP server of your application will expose them by default on http://localhost:8081/metrics, but you can also see them on your core dashboard:</p> <p> </p> <p>You can see that, by default, the worker module automatically collects execution metrics on your workers.</p> <p>Let's now add an example custom metric in our <code>SubscribeWorker</code> to count the number of received messages:</p> internal/worker/subscribe.go<pre><code>package worker\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"cloud.google.com/go/pubsub\"\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log\"\n    \"github.com/ankorstore/yokai/trace\"\n    \"github.com/prometheus/client_golang/prometheus\"\n)\n\nvar SubscribeCounter = prometheus.NewCounter(prometheus.CounterOpts{\n    Name: \"messages_received_total\",\n    Help: \"Total number of received messages\",\n})\n\ntype SubscribeWorker struct {\n    config *config.Config\n    client *pubsub.Client\n}\n\nfunc NewSubscribeWorker(config *config.Config, client *pubsub.Client) *SubscribeWorker {\n    return &amp;SubscribeWorker{\n        config: config,\n        client: client,\n    }\n}\n\nfunc (w *SubscribeWorker) Name() string {\n    return \"subscribe-worker\"\n}\n\nfunc (w *SubscribeWorker) Run(ctx context.Context) error {\n    subscription := w.client.Subscription(w.config.GetString(\"config.subscription.id\"))\n\n    return subscription.Receive(ctx, func(c context.Context, msg *pubsub.Message) {\n        c, span := trace.CtxTracerProvider(c).Tracer(w.Name()).Start(c, fmt.Sprintf(\"%s span\", w.Name()))\n        defer span.End()\n\n        logger := log.CtxLogger(c)\n\n        logger.Info().Msgf(\"in %s\", w.Name())\n\n        logger.Info().Msgf(\n            \"received message: id=%v, data=%v\",\n            msg.ID,\n            string(msg.Data),\n        )\n\n        msg.Ack()\n\n        SubscribeCounter.Inc()\n    })\n}\n</code></pre> <p>To collect this metric, we need to register it with <code>fxmetrics.AsMetricsCollector()</code> in <code>internal/register.go</code>:</p> internal/register.go<pre><code>package internal\n\nimport (\n    \"github.com/ankorstore/yokai/fxmetrics\"\n    \"github.com/ankorstore/yokai/fxworker\"\n    \"github.com/foo/bar/internal/worker\"\n    \"go.uber.org/fx\"\n)\n\nfunc Register() fx.Option {\n    return fx.Options(\n        // metrics\n        fxmetrics.AsMetricsCollector(worker.SubscribeCounter),\n        // ...\n    )\n}\n</code></pre> <p>If you publish another message, you can then check the metrics on the core metrics endpoint:</p> [GET] http://localhost:8081/metrics<pre><code># ...\n# HELP messages_received_total Total number of received messages\n# TYPE messages_received_total counter\nmessages_received_total 1\n</code></pre>"},{"location":"tutorials/worker-application/#testing","title":"Testing","text":"<p>At this stage, we are able to subscribe to Pub/Sub, and we have observability signals to monitor this.</p> <p>The next step is to provide tests for your application, to ensure it's behaving as expected.</p>"},{"location":"tutorials/worker-application/#configuration","title":"Configuration","text":"<p>Yokai's bootstrapper provides a <code>RunTest()</code> function to start your application in <code>test</code> mode.</p> <p>This will automatically set the env var <code>APP_ENV=test</code>, and will load your test configuration.</p> <p>For our tests, we can configure:</p> <ul> <li>the log module to send logs to a <code>test buffer</code></li> <li>the trace module to send trace spans to a <code>test exporter</code></li> <li>the fxgcppubsub module test <code>project</code>, <code>topic</code> and <code>subscription</code> to use</li> </ul> <p>Let's set the testing configuration in <code>config/config.test.yaml</code> and activate the <code>debug</code>:</p> config/config.test.yaml<pre><code>app:\n  debug: true\nmodules:\n  gcppubsub:\n    project:\n      id: test-project\n    healthcheck:\n      subscriptions:\n        - tes-subscription\nconfig:\n  topic:\n    id: test-topic\n  subscription:\n    id: test-subscription\n</code></pre>"},{"location":"tutorials/worker-application/#implementation_1","title":"Implementation","text":"<p>We can now provide <code>functional</code> tests for your worker.</p> <p>Let's create our <code>TestSubscribeWorker</code> test in the <code>worker_test</code> package:</p> internal/worker/subscribe_test.go<pre><code>package worker_test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"strings\"\n    \"testing\"\n    \"time\"\n\n    \"cloud.google.com/go/pubsub\"\n    \"github.com/ankorstore/yokai/config\"\n    \"github.com/ankorstore/yokai/log/logtest\"\n    \"github.com/ankorstore/yokai/trace/tracetest\"\n    \"github.com/foo/bar/internal\"\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/testutil\"\n    \"github.com/stretchr/testify/assert\"\n    \"go.opentelemetry.io/otel/attribute\"\n    \"go.uber.org/fx\"\n)\n\nfunc TestSubscribeWorker(t *testing.T) {\n    ctx := context.Background()\n\n    // env vars\n    t.Setenv(\"APP_CONFIG_PATH\", fmt.Sprintf(\"%s/configs\", internal.RootDir))\n\n    var client *pubsub.Client\n    var logBuffer logtest.TestLogBuffer\n    var traceExporter tracetest.TestTraceExporter\n    var metricsRegistry *prometheus.Registry\n\n    // bootstrap test app\n    app := internal.Bootstrapper.BootstrapTestApp(\n        t,\n        fx.Invoke(func(config *config.Config, client *pubsub.Client) error {\n            // prepare test topic\n            topicName := config.GetString(\"config.topic.id\")\n            subscriptionName := config.GetString(\"config.subscription.id\")\n\n            topic, err := client.CreateTopic(ctx, topicName)\n            if err != nil {\n                return fmt.Errorf(\"cannot create test topic %s: %w\", topicName, err)\n            }\n\n            // prepare test subscription\n            _, err = client.CreateSubscription(ctx, subscriptionName, pubsub.SubscriptionConfig{\n                Topic:       topic,\n                AckDeadline: 10 * time.Second,\n            })\n            if err != nil {\n                return fmt.Errorf(\"cannot create test subscription %s: %w\", subscriptionName, err)\n            }\n\n            return nil\n        }),\n        fx.Populate(\n            &amp;client,\n            &amp;logBuffer,\n            &amp;traceExporter,\n            &amp;metricsRegistry,\n        ),\n    )\n\n    // start test app\n    app.RequireStart()\n\n    // publish test message\n    testMessage := \"test message\"\n\n    result := client.Topic(\"test-topic\").Publish(ctx, &amp;pubsub.Message{\n        Data: []byte(testMessage),\n    })\n\n    id, err := result.Get(ctx)\n    assert.NoError(t, err)\n\n    // stop test app (after 100 ms wait to avoid test flakiness)\n    time.Sleep(100 * time.Millisecond)\n\n    app.RequireStop()\n\n    // logs assertion\n    logtest.AssertHasLogRecord(t, logBuffer, map[string]interface{}{\n        \"level\":   \"info\",\n        \"service\": \"pubsub-worker\",\n        \"module\":  \"worker\",\n        \"worker\":  \"subscribe-worker\",\n        \"message\": fmt.Sprintf(\"received message: id=%v, data=%s\", id, testMessage),\n    })\n\n    // trace assertion\n    tracetest.AssertHasTraceSpan(\n        t,\n        traceExporter,\n        \"subscribe-worker span\",\n        attribute.String(\"Worker\", \"subscribe-worker\"),\n    )\n\n    // metrics assertion\n    expectedMetric := `\n        # HELP messages_received_total Total number of received messages\n        # TYPE messages_received_total counter\n        messages_received_total 1\n    `\n\n    err = testutil.GatherAndCompare(\n        metricsRegistry,\n        strings.NewReader(expectedMetric),\n        \"messages_received_total\",\n    )\n    assert.NoError(t, err)\n}\n</code></pre> <p>In this functional test:</p> <ul> <li>we start the application in test mode</li> <li>we create the Pub/Sub test topic and subscription</li> <li>we use the Pub/Sub client to publish a message on the test server</li> <li>we assert on the worker logs to ensure it got the message</li> <li>we assert on the observability signals (logs, traces and metrics)</li> </ul> <p>You can then run <code>make test</code>:</p> <pre><code>=== RUN   TestSubscribeWorker\n--- PASS: TestSubscribeWorker (0.00s)\nPASS\n</code></pre> <p>This tutorial will only cover testing of the <code>SubscribeWorker</code> as example, you need to provide other <code>functional</code> tests and the classic <code>unit</code> and <code>integration</code> tests for the rest of your application.</p> <p>Thanks to Yokai's dependency injection system and testing tools, it's easy to provide mocks as dependencies for your implementations.</p>"}]}